---
title: "单细胞数据分析之蛋白活性推断篇"
date: 2024-11-20T23:10:09Z
draft: ["false"]
tags: [
  "fetched",
  "单细胞空间交响乐"
]
categories: ["Acdemic"]
---
单细胞数据分析之蛋白活性推断篇 by 单细胞空间交响乐
------
<div><h4 data-line="2"><strong>世事无常</strong><br></h4><h4 data-line="4"><strong>315打假日</strong></h4><h4 data-line="4"><br></h4><h4 data-line="8">  2月26日获知家里电信诈骗，到今日过去了17天，从一开始的震惊，到冷静也仅用了3天，我特别感谢那些帮助了我的人，很多人无偿捐助了我。</h4><h4 data-line="10">  很多人都还是学生，将来都会走向社会，进入岗位，其中有一些人也会遇到很大的挫折，我希望大家遇到挫折的时候可以想起我，我这么倒霉的情况下，依然要相信，生活还是很美好的，大多数人的挫折比起我来，也就不再是挫折了。</h4><p data-line="12"> 今天我们来分享一个关于蛋白活性推断的内容，最近一段时间因为一篇文章的发表，运用基因表达来推断蛋白活性，文章在<strong><span>Single-cell protein activity analysis identifies recurrence-associated renal tumor macrophages</span></strong>，杂志 Cell，顶刊，其中就用到了单细胞转录组数据来推断蛋白活性，其中用到的软件是<strong><span>viper</span></strong>,2021年5月的一个软件，值得关注。</p><p data-line="14"><strong>推断原理</strong></p><p data-line="16">   VIPER(Virtual Inference of Protein-activity by Enriched Regulon analysis)算法允许在单个样本的基础上，<strong>从基因表达谱数据计算蛋白质活性推断</strong>。它利用最直接受特定蛋白质调控的基因表达，如转录因子(TF)的靶标，作为其活性的准确推断手段。</p><p data-line="18">  viper实现了一种专门用于估计调控活性的算法，该算法考虑了调节子的作用模式， regulator-target gene相互作用的可信度和每个靶基因调控的多效性。</p><p data-line="20">  VIPER在这个包中提供了两种推断方法:多样本版本(msVIPER)设计用于基于多个样本或表达谱的基因表达特征，<strong>以及单样本版本(VIPER)，它在逐个样本的基础上估计相对蛋白质活性，从而允许将典型的基因表达矩阵(即多个样本中的多个mRNA)转换为蛋白质活性矩阵，表示每个样本中每个蛋白质的相对活性</strong>。</p><h4 data-line="22"><strong>看一下实例代码</strong></h4><h5 data-line="23">安装，其中bcellViper提供了示例数据和需要的调控网络作为参考</h5><pre></pre><section><ul><li><li><li><li><li><li><li><li></ul><pre data-lang="php"><code><span><span>if</span> (!requireNamespace(<span>"BiocManager"</span>, quietly=<span>TRUE</span>))</span></code><code><span>+ install.packages(<span>"BiocManager"</span>)</span></code><code><span>BiocManager::install(<span>"mixtools"</span>)</span></code><code><span>BiocManager::install(<span>"bcellViper"</span>)</span></code><code><span>BiocManager::install(<span>"viper"</span>)</span></code><code><span><br></span></code><code><span><span>#Getting started</span></span></code><code><span>library(viper)</span></code></pre></section><pre></pre><h5 data-line="35"><strong>Generating the regulon object</strong></h5><p><br></p><p data-line="36">需要输入两个文件</p><ul><li><p>gene expression signature</p></li><li><p>an appropriate cell context-specific regulatory network. This regulatory network is provided in the format of a class <em>regulon</em>  object</p></li></ul><h5 data-line="39">调控文件通常是由 ARACNe的输出文件产生的，我们来看一下分析过程：</h5><ul><li><p>由于ARACNe的资源消耗问题，所有对于单细胞数据针对每个cluster进行计算</p></li><li><p>为了生成准确的、鲁棒性好的ARACNe network，<strong>ARACNe需要输入表达矩阵中细胞的大部分转录结构相同的数据</strong>。对于单细胞转录组数据而言，这需要在生成ARACNenetwork之前将数据中的细胞进行clustering。这个cluster可以通过多种方式获取：任何一种用于单细胞聚类分群的方法都可以，也可以是简单的通过前几个主成分进行的简单聚类分群。PISCES包中的Clustering方法有：PartitionAround Medioids (PAM), Multi-Way K-Means, and Louvain with ResolutionOptimization。PISCES软件使用的是基于Seurat与PISCES R Package 对数据进行的two stepoptimize resolution cluster：所有的clustering step均分两步完成。<strong>Seurat中FindNeighbors与FindClusters函数使用的是Louvain算法，这种算法的缺陷是会导致过度分群</strong>。因此，在0.01~1.0的分辨率（resolution）范围内进行聚类以0.01为间隔，并在每个分辨率值上评估聚类质量，以在此范围内选择最佳的聚类方式。对于每个分辨率值（resolution），将cluster中的细胞数再次取样至1000，并计算这1000个细胞及其cluster标签的silhouettescore。对于基因表达数据，Pearsoncorrelation被用于细胞距离矩阵（就是用CorDist函数算出来的dist.mat）被用于计算silhouettescore。对于VIPER推断出来的蛋白活性数据，VIPER包中的ViperSimilarity函数计算出的distancemetric被用于计算silhouettescore。这个过程会针对这1000个细胞随机进行100次，然后得出一个针对一个resolution的mean and standarddeviation of average silhouette score。选择使平均silhouettescore最大化的最高resolution值作为对数据进行聚类而不过度聚类的最佳resolution。<br>Clustering完成后就可以产生meta-cells用于输入ARACNe：<strong>将cluster中距离最近的10个细胞的reads相加后进一步re-normalizing,生成一个具有250个sample的矩阵用于后续ARACNe（这个地方操作起来有点复杂，资源可以的话将所有细胞输入进行计算）</strong>。<br><strong>    如果在数据集中的不同细胞类型已经进行了定义和注释，那么cell-type specific networks可以基于细胞注释得出</strong>。然而，由于无监督下的（无细胞定义与注释）PISCES 计算可以进一步确认实验的设计是否有问题并可能进一步得出新的生物学发现，因此推荐无监督下的PISCES 计算。<strong>这里大家就用定义好的Seurat分群就可以了。</strong></p></li></ul><pre></pre><section><ul><li><li><li><li><li></ul><pre data-lang="objectivec"><code><span><span># Seurat clustering</span></span></code><code><span>sce.combined.sct &lt;- RunPCA(sce.combined.sct, verbose = <span>FALSE</span>)</span></code><code><span>sce.combined.sct &lt;- RunUMAP(sce.combined.sct, dims = <span>1</span>:<span>30</span>, verbose = <span>FALSE</span>)</span></code><code><span>sce.combined.sct &lt;- FindNeighbors(sce.combined.sct, dims = <span>1</span>:<span>30</span>, verbose = <span>FALSE</span>)</span></code><code><span>sce.combined.sct &lt;- FindClusters(sce.combined.sct, method = <span>"igraph"</span> ,verbose = <span>FALSE</span>)</span></code></pre></section><pre><code><br></code></pre><h4 data-line="53">这样的话，抽取每个cluster的矩阵进行下游推断即可，如果cluster的细胞数过多，则需要下采用或者合并。</h4><p><br></p><p data-line="55"><strong>ARACNe-network generation</strong></p><p data-line="57">从这里开始<span><strong>ARACNe-AP的教程</strong></span>，这部分内容可以基于windows平台的Terminal或者linux平台完成，这里使用的是linux平台，方法大同小异。</p><ul><li><p>先下载基于ARACNe-AP作者放在Github上的ARACNe-AP压缩包，将解压后的文件上传至linux服务器并放在后续ARACNe工作目录下并解压；</p></li><li><p>分别下载并安装JAVA和ANT，并设置相应环境变量<br>下载JAVA-JDK：https://www.oracle.com/java/technologies/downloads/#java8<br>下载ANTs:https://ant.apache.org/bindownload.cgi</p></li><li><p>Xshell或MAC-Terminal登录linux服务器</p></li></ul><section><ul><li><li></ul><pre data-lang="perl"><code><span><span>mkdir</span> JAVA_JDK<span>#创建JAVA安装位置</span></span></code><code><span><span>mkdir</span> ANTs    <span>#创建ANTs安装位置</span></span></code></pre></section><pre><code><br></code></pre><ul><li><p>将下载好的JDK与ANTs安装文件分别传送至服务器的“/JAVA_JDK”与“/ANTs”文件夹中</p></li><li><p>安装软件:分别进入到/JAVA_JDK”与“/ANTs”文件夹中，解压文件</p></li></ul><section><ul><li><li></ul><pre data-lang="properties"><code><span><span>tar</span> <span>-zxvf /your/pathway/to/apache-ant-1.9.14-bin.tar.gz</span></span></code><code><span><span>tar</span> <span>-zxvf /your/pathway/to/jdk-8u131-linux-x64.tar.gz</span></span></code></pre></section><pre></pre><ul><li><p>配置环境文件，进入到个人目录下<br>vi .profile #使用文本编辑器打开并编辑“.profile”文件</p></li><li><p>分别为JAVA与ANT增加环境变量,编辑一下内容加入到“.profile”文件</p></li></ul><pre></pre><section><ul><li><li><li><li><li><li></ul><pre data-lang="bash"><code><span><span>export</span> JAVA_HOME=/YOUR/PATHWAY/TO/jdk1.8.0_211 </span></code><code><span><span>export</span> CLASSPATH=$:CLASSPATH:<span>$JAVA_HOME</span>/lib/ </span></code><code><span><span>export</span> PATH=<span>$PATH</span>:<span>$JAVA_HOME</span>/bin</span></code><code><span><br></span></code><code><span><span>export</span> ANT_HOME=/YOUR/PATHWAY/TO/apache-ant-1.9.15/</span></code><code><span><span>export</span> PATH=<span>$ANT_HOME</span>/bin:<span>$PATH</span></span></code></pre></section><ul><li><p>进入ARACNe工作目录，检查JAVA与ANT是否安装成功, 如果安装成功输入以下命令会弹出详细版本号</p></li></ul><pre></pre><section><ul><li><li><li></ul><pre data-lang="properties"><code><span><span>source</span> <span>.profile</span></span></code><code><span><span>java</span> <span>-version</span></span></code><code><span><span>ant</span> <span>-version</span></span></code></pre></section><ul><li><p>构建JAVA需要的aracne.jar文件</p></li></ul><section><ul><li></ul><pre data-lang="nginx"><code><span><span>ant</span> main</span></code></pre></section><pre></pre><ul><li><p>构建ARACNe-network需要两个文件：<strong>表达矩阵（Matrix）与基因列表(list)</strong>，注意表达矩阵中使用ensembl ID，那么基因列表也需要是ensembl ID, 如果矩阵中使用gene symble,那么基因列表也需要是gene symble。<strong>这两个文件都放在ARACNe-AP-master.zip解压后的test文件夹中，运行参数中的文件名一定要与你文件夹中的文件名一致，否则java在调用这个文件的时候会报错</strong></p></li><li><p><strong>表达矩阵</strong>：单细胞基因表达矩阵，txt格式；</p></li><li><p><strong>基因列表</strong>：使用PISCES作者给的："tfs-hugo.txt", COTFs-"cotfs-hugo.txt",Signaling Proteins-"sig-hugol.txt"，因为是三个基因集（文件可以在PISCES作者的github上下载：https://github.com/califano-lab/PISCES/tree/master/data，这里除了有上述提到的3个基因集，还有一个surface基因集，演示过程没有使用），因此针对每一个cluster的表达矩阵都需要跑三遍ARACNe流程，再将最后的三个文件合并成一个，即得到这个cluster的ARACNe-network。当然基因集可以合并</p></li></ul><pre></pre><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="bash"><code><span><span>#Step1 Calculate threshold with a fixed seed</span></span></code><code><span>java -Xmx5G -jar dist/aracne.jar -e 单细胞cluster矩阵txt  -o outputFolder --tfs <span>test</span>/tfs.txt --pvalue 1E-8 --seed 1 \--calculateThreshold</span></code><code><span><span>#Step2: Run ARACNe on a single bootstrap</span></span></code><code><span>java -Xmx5G -jar dist/aracne.jar -e 单细胞cluster矩阵txt  -o outputFolder --tfs <span>test</span>/tfs.txt --pvalue 1E-8 --seed 1</span></code><code><span><span>#Step3: Run 100 reproducible bootstraps</span></span></code><code><span><span>for</span> i <span>in</span> {1..100}</span></code><code><span><span>do</span></span></code><code><span>java -Xmx5G -jar dist/aracne.jar -e 单细胞cluster矩阵txt  -o outputFolder --tfs <span>test</span>/tfs.txt --pvalue 1E-8 --seed <span>$i</span></span></code><code><span><span>done</span></span></code><code><span><span>#Step4: Consolidate bootstraps in the output folder</span></span></code><code><span>java -Xmx5G -jar dist/aracne.jar -o outputFolder --consolidate</span></code><code><span><span>#Step5: Run a single ARACNE with no bootstrap and no DPI</span></span></code><code><span>java -Xmx5G -jar dist/aracne.jar -e 单细胞cluster矩阵txt  -o outputFolder --tfs <span>test</span>/tfs.txt --pvalue 1E-8 --seed 1 \ --nobootstrap --nodpi</span></code><code><span><span>#Step6: Consolidate bootstraps without Bonferroni correction</span></span></code><code><span>java -Xmx5G -jar dist/aracne.jar -o outputFolder --consolidate --nobonferroni</span></code></pre></section><pre><code><br></code></pre><ul><li><p>最后在当前工作目录下进入“outputFolder",里面的”network.txt“就是要的结果，我们将一个矩阵针对tfs-hugo.txt、cotfs-hugo.txt、sig-hugol.txt的三次运行结果合并在一起，并使用文本打开network.txt文件，将其表头“RegulatorTarget MIpvalue”删除，保存后修改文件后缀为tsv，就可以将其输入RegProcess()函数了。最终得到的文件就是这个矩阵的ARACNe-network，几个矩阵就有几个ARACNe-network。</p></li><li><p>然后将输出结果中的 .adj file和基因表达矩阵，转换成 <em>regulon</em> <br>  object.</p><p><br></p></li></ul><p><br></p><p data-line="133"><strong>Protein activity based clustering analysis</strong></p><p data-line="133">构建的ARACNe-network通过RegProcess()函数将每一个cluster的ARACNe-network文件（pisces-1-net-final.tsv）与其相应的表达矩阵基因表达矩阵（MetaCells函数生成的表达矩阵）进行综合并生成一个调节子对象文件（pisces-1-net-pruned.rds）。</p><section><ul><li><li><li><li><li><li><li></ul><pre data-lang="cs"><code><span>RegProcess &lt;- function(a.file, exp.mat, <span>out</span>.dir, <span>out</span>.name = <span>'.'</span>) {</span></code><code><span>  require(viper)</span></code><code><span>  processed.reg &lt;- aracne2regulon(afile = a.file, eset = exp.mat, format = <span>'3col'</span>)</span></code><code><span>  saveRDS(processed.reg, file = paste(<span>out</span>.dir, <span>out</span>.name, <span>'unPruned.rds'</span>, sep = <span>''</span>))</span></code><code><span>  pruned.reg &lt;- pruneRegulon(processed.reg, <span>50</span>, adaptive = FALSE, eliminate = TRUE)</span></code><code><span>  saveRDS(pruned.reg, file = paste(<span>out</span>.dir, <span>out</span>.name, <span>'pruned.rds'</span>, sep = <span>''</span>))</span></code><code><span>}</span></code></pre></section><pre></pre><pre></pre><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="cs"><code><span><span>#针对每个cluster（3个为例）</span></span></code><code><span>RegProcess(<span>'pisces-1-net-final.tsv'</span>, mat1, <span>out</span>.dir = <span>'tutorial/'</span>, <span>out</span>.name = <span>'pisces-1-net-'</span>)</span></code><code><span>RegProcess(<span>'pisces-2-net-final.tsv'</span>, mat2, <span>out</span>.dir = <span>'tutorial/'</span>, <span>out</span>.name = <span>'pisces-2-net-'</span>)</span></code><code><span>RegProcess(<span>'pisces-3-net-final.tsv'</span>, mat3, <span>out</span>.dir = <span>'tutorial/'</span>, <span>out</span>.name = <span>'pisces-3-net-'</span>)</span></code><code><span><br></span></code><code><span><span>#RegProcess()函数生成的文件保存为rds格式，先使用readRDS()函数读进来。</span></span></code><code><span>c1.net &lt;- readRDS(<span>'pisces-1-net-pruned.rds'</span>)</span></code><code><span>c2.net &lt;- readRDS(<span>'pisces-2-net-pruned.rds'</span>)</span></code><code><span>c3.net &lt;- readRDS(<span>'pisces-3-net-pruned.rds'</span>)</span></code><code><span><span>#使用list()函数构建net.list文件</span></span></code><code><span>net.list&lt;-list(c1.net,c2.net,c3.net)</span></code><code><span><br></span></code><code><span><span>## viper and protein-activity based clustering</span></span></code><code><span><span>## net.list here would be a list of networks generated from ARACNe</span></span></code><code><span>sce.combined.sct &lt;- AddProteinAssay(sce.combined.sct)<span>#将Seurat对象里的count矩阵拿出来命名为PISCES，然后放回到Seurat对象里去，并设置为当前默认的active.assay</span></span></code><code><span>sce.combined.sct &lt;- CPMTransform(sce.combined.sct)<span>#针对PISCESassay进行CPMTransform()、GESTransform()标准化。</span></span></code><code><span>sce.combined.sct &lt;- GESTransform(sce.combined.sct)</span></code><code><span>sce.combined.sct &lt;- PISCESViper(sce.combined.sct, net.list)<span>#蛋白活性推断</span></span></code></pre></section><pre><code><br></code></pre><p data-line="164">推断出最终的VIPER矩阵（蛋白活性矩阵），就可以对细胞重新进行clustering。VIPER结果通常允许分辨出更小的、转录上更不同的cluster。然后这些cluster可以被用于鉴定masterregulator protein。也可以运用蛋白矩阵进行下游的再分析以及更多的个性化分析。</p><p><img data-ratio="0.4759259259259259" data-src="https://mmbiz.qpic.cn/mmbiz_png/srXAibe95MmmCEDHibzicukaicubNictfXAKv9LuYnNXObScCSRV1ibM4Nk8aJSJOAh3U8QicJxwNv6rJI9ic4jj9kC66A/640?wx_fmt=png" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/srXAibe95MmmCEDHibzicukaicubNictfXAKv9LuYnNXObScCSRV1ibM4Nk8aJSJOAh3U8QicJxwNv6rJI9ic4jj9kC66A/640?wx_fmt=png"><br></p><p>左：差异基因热图；右：差异蛋白表达热图</p><h4 data-line="169"><span><strong>生活很好，有你更好。</strong></span></h4><p><span><br><br></span></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/J0eCk15f9ppaqUjhyaALPw",target="_blank" rel="noopener noreferrer">原文链接</a>
