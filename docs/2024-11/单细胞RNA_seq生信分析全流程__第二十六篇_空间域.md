---
title: "单细胞RNA-seq生信分析全流程——第二十六篇：空间域"
date: 2024-11-24T23:07:51Z
draft: ["false"]
tags: [
  "fetched",
  "小鱼生物信息"
]
categories: ["Acdemic"]
---
单细胞RNA-seq生信分析全流程——第二十六篇：空间域 by 小鱼生物信息
------
<div><p><span><strong><span><strong><span>26.1 前言</span></strong></span></strong></span></p><p>在分析空间组学数据集时，我们可能对识别数据中的空间模式<span>感兴趣，即识别在</span>空间<span>中变化的特征。空间组学数据不仅需要通常的细胞 x 基因矩阵，还需要正交信息，我们可以使用这些信息来描述和预测数据中感兴趣的特征，例如组织图像和空间坐标。</span></p><p><span>细胞类型或状态的识别是数据分析的首要任务之一，因为它允许从数据中提出关键假设。这通常是通过基于特征空间中数据点之间的某种相似性对数据进行聚类来执行的。此任务最流行的方法之一是在数据的（低维）表示上计算最近邻图，然后在该图上执行社区检测。对于空间组学数据，这种方法可以轻松扩展以解释数据在坐标空间（而不仅仅是特征空间）中的相似性。我们可以将此任务称为“空间域识别”，因为它包括用于聚类识别的基因和空间相似性。</span></p><p><span>已经开发出不同的模型来识别具有不同底层概念的空间域。它们通常可以分为两组方法。第一种模型模拟基因表达的空间依赖性，第二种模型还结合了从组织学图像中提取的信息。</span></p><p><span><img data-imgfileid="100000441" data-ratio="0.6526824307144673" data-src="https://mmbiz.qpic.cn/mmbiz_jpg/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLbZ4w4jpjtO54wxa5mMTCVTb7U3TD67soIBWDHPsmrqzRKgxb9YLGMg/640?wx_fmt=jpeg&amp;from=appmsg" data-type="jpeg" data-w="3933" src="https://mmbiz.qpic.cn/mmbiz_jpg/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLbZ4w4jpjtO54wxa5mMTCVTb7U3TD67soIBWDHPsmrqzRKgxb9YLGMg/640?wx_fmt=jpeg&amp;from=appmsg"></span></p><p><span>我们将展示如何在Squidpy中计算空间域以及如何应用spaGCN。</span></p><h2><span><strong><span>26.2 </span></strong><strong><span>环境设置和数据</span></strong></span></h2><p><span>我们首先加载本教程所需的包和数据集。</span></p><section><ul><li><li><li><li><li></ul><pre data-lang="javascript"><code><span>import scanpy as sc</span></code><code><span>import squidpy as sq</span></code><code><span><br></span></code><code><span>sc.settings.verbosity = 3</span></code><code><span>sc.settings.set_figure_params(dpi=80, facecolor="white")</span></code></pre></section><p><span>本教程中使用的数据集由 1 只小鼠的 1 个组织切片组成，由</span><span>10x Genomics Space Ranger 1.1.0</span><span>提供。该数据集在 Squidpy 中进行了预处理，它为该数据集提供了加载功能。我们简要检查一下返回的 AnnData 对象。</span></p><section><ul><li><li></ul><pre data-lang="makefile"><code><span>adata = sq.datasets.visium_hne_adata()</span></code><code><span>adata</span></code></pre></section><section><ul><li><li><li><li><li><li><li></ul><pre data-lang="javascript"><code><span>AnnData object with n_obs × n_vars = 2688 × 18078</span></code><code><span>    obs: 'in_tissue', 'array_row', 'array_col', 'n_genes_by_counts', 'log1p_n_genes_by_counts', 'total_counts', 'log1p_total_counts', 'pct_counts_in_top_50_genes', 'pct_counts_in_top_100_genes', 'pct_counts_in_top_200_genes', 'pct_counts_in_top_500_genes', 'total_counts_mt', 'log1p_total_counts_mt', 'pct_counts_mt', 'n_counts', 'leiden', 'cluster'</span></code><code><span>    var: 'gene_ids', 'feature_types', 'genome', 'mt', 'n_cells_by_counts', 'mean_counts', 'log1p_mean_counts', 'pct_dropout_by_counts', 'total_counts', 'log1p_total_counts', 'n_cells', 'highly_variable', 'highly_variable_rank', 'means', 'variances', 'variances_norm'</span></code><code><span>    uns: 'cluster_colors', 'hvg', 'leiden', 'leiden_colors', 'neighbors', 'pca', 'rank_genes_groups', 'spatial', 'umap'</span></code><code><span>    obsm: 'X_pca', 'X_umap', 'spatial'</span></code><code><span>    varm: 'PCs'</span></code><code><span>    obsp: 'connectivities', 'distances'</span></code></pre></section><section><ul><li></ul><pre data-lang="javascript"><code><span>sq.pl.spatial_scatter(adata, color="cluster", figsize=(10, 10))</span></code></pre></section><p><img data-imgfileid="100000442" data-ratio="0.5234857849196539" data-src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLeTQWsPQ09e24cFEza3zUFtNRsPZCklwu19gJWwax8mY4BthlmeibnHw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1618" src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLeTQWsPQ09e24cFEza3zUFtNRsPZCklwu19gJWwax8mY4BthlmeibnHw/640?wx_fmt=png&amp;from=appmsg"></p><h2><span><strong><span>26.3 </span></strong><strong><span>Squidpy 中的空间域</span></strong></span></h2><h2><span>在本节中，我们将使用 Squidpy 的教学示例说明这种方法，然后指出一种更高级的算法来完成此任务。</span></h2><p><span>为了本示例的目的，我们使用 Visium 数据集。在本例中，我们将使用术语“点”来指代存储在 AnnData 对象行中的观察值。首先，我们需要一种算法来编码某些坐标空间（例如基因表达空间和空间坐标）中观察值之间的相似性。最近邻图是此任务的可靠表示。让我们计算空间坐标中的最近邻图和 PCA 坐标中的最近邻图。正如我们所见，基于`adata.obsm['X_pca']`已经在数据集上执行的 PCA，因此我们可以直接计算 KNN 图。</span></p><section><ul><li><li><li><li><li><li></ul><pre data-lang="makefile"><code><span># nearest neighbor graph</span></code><code><span>sc.pp.neighbors(adata)</span></code><code><span>nn_graph_genes = adata.obsp["connectivities"]</span></code><code><span># spatial proximity graph</span></code><code><span>sq.gr.spatial_neighbors(adata)</span></code><code><span>nn_graph_space = adata.obsp["spatial_connectivities"]</span></code></pre></section><section><ul><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="sql"><code><span>computing neighbors</span></code><code><span>    using 'X_pca' with n_pcs = 50</span></code><code><span>    finished: added to `.uns['neighbors']`</span></code><code><span>    `.obsp['distances']`, distances for each pair of neighbors</span></code><code><span>    `.obsp['connectivities']`, weighted adjacency matrix (0:00:08)</span></code><code><span>Creating graph using `grid` coordinates and `None` transform and `1` libraries.</span></code><code><span>Adding `adata.obsp['spatial_connectivities']`</span></code><code><span>       `adata.obsp['spatial_distances']`</span></code><code><span>       `adata.uns['spatial_neighbors']`</span></code><code><span>Finish (0:00:00)</span></code></pre></section><p><span>其次，我们希望联合识别两种社区（集群）。一种简单的方法是简单地将两个图相加，然后在联合图上计算 leiden。我们还可以根据超参数对每个图的重要性进行加权</span><code><span>alpha</span></code><span>。</span></p><section><ul><li><li><li><li></ul><pre data-lang="makefile"><code><span>alpha = 0.2</span></code><code><span><br></span></code><code><span>joint_graph = (1 - alpha) * nn_graph_genes + alpha * nn_graph_space</span></code><code><span>sc.tl.leiden(adata, adjacency=joint_graph, key_added="squidpy_domains")</span></code></pre></section><section><ul><li><li><li></ul><pre data-lang="nginx"><code><span>running Leiden clustering</span></code><code><span>    finished: found 17 clusters and added</span></code><code><span>    'squidpy_domains', the cluster labels (adata.obs, categorical) (0:00:00)</span></code></pre></section><p><span>让我们用 Squidpy 将结果可视化。第一个注释（</span><code><span>cluster</span></code><span>）是仅基于基因表达相似性的聚类注释。</span></p><section><ul><li></ul><pre data-lang="javascript"><code><span>sq.pl.spatial_scatter(adata, color=["cluster", "squidpy_domains"], wspace=0.9)</span></code></pre></section><p><img data-imgfileid="100000443" data-ratio="0.2980099502487562" data-src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLl1joicf8TCR9H7ic72jz5m5B6QLm6NnRg23GrzYdnP8wpaqkXOIBaiaug/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="2010" src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLl1joicf8TCR9H7ic72jz5m5B6QLm6NnRg23GrzYdnP8wpaqkXOIBaiaug/640?wx_fmt=png&amp;from=appmsg"></p><p><span>我们可以看到，这种方法本质上是基于空间距离“平滑”聚类注释。尽管这是一种纯粹的方法展示，但它已在实践中使用。</span></p><h2><span><strong><span>26.4 </span></strong><strong><span>SpaGCN </span></strong></span></h2><h2><span>我们在本教程中展示的第二种方法是 SpaGCN。SpaGCN是一种图卷积网络方法，它在空间组学数据分析中利用基因表达、空间位置和组织学。SpaGCN将基因表达、空间信息和组织学图像结合在一个无向加权图中。该图表示数据中存在的整体空间依赖关系，可用于图卷积方法中以识别空间域。</span></h2><p><span>现在我们展示如何在实践中使用SpaGCN。我们首先加载相应的附加包：</span></p><section><ul><li><li><li><li><li></ul><pre data-lang="swift"><code><span>import SpaGCN as spg</span></code><code><span><br></span></code><code><span>import numpy as np</span></code><code><span>from PIL import Image</span></code><code><span>import requests</span></code></pre></section><p><span>如前所述，SpaGCN 将空间数据集的组织学图像作为附加输入。为此，我们另外将 10X Genomics 网站上的高分辨率 tif 加载到我们的笔记本中。SpaGCN 也可以在没有组织学信息的情况下使用。我们稍后会提到它。</span></p><section><ul><li><li><li><li><li><li><li><li></ul><pre data-lang="makefile"><code><span>img = np.asarray(</span></code><code><span>    Image.open(</span></code><code><span>        requests.get(</span></code><code><span>            "https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Adult_Mouse_Brain/V1_Adult_Mouse_Brain_image.tif",</span></code><code><span>            stream=True,</span></code><code><span>        ).raw</span></code><code><span>    )</span></code><code><span>)</span></code></pre></section><p><span><span>本教程中的空间 AnnData对象已处理。为了确保我们应用了 SpaGCN 所需的正确数据处理，我们将重置</span>`adata.X`为<span>原始计数。</span></span></p><section><ul><li><li></ul><pre data-lang="shell"><code><span># requires raw data in X</span></code><code><span>adata.X = adata.raw.X</span></code></pre></section><h2><span>26.4.1 将基因表达和组织学整合到图表中</span></h2><h2><span>SpaGCN 需要将空间数组坐标以及像素坐标传递给模型。数组坐标通常存储在`adata.obs["array_row"]`和`adata.obs["array_col"]`。像素坐标存储在中`adata.obsm["spatial"]`。</span></h2><section><ul><li><li><li><li><li></ul><pre data-lang="markdown"><code><span># Set coordinates</span></code><code><span>x_array = adata.obs["array_row"].tolist()</span></code><code><span>y_array = adata.obs["array_col"].tolist()</span></code><code><span>x_pixel = (adata.obsm["spatial"][:, 0]).tolist()</span></code><code><span>y_pixel = adata.obsm["spatial"][:, 1].tolist()</span></code></pre></section><p><span>首先，SpaGCN 将基因表达和组织学信息以邻接矩阵的形式聚合到联合图中。如果两个点在物理上接近并且具有从图像中提取的相似组织学特征，则认为它们是相连的。相应的函数需要用户传递 x 和 y 像素空间、图像以及另外两个参数：beta和alpha。</span></p><ul><li><p><span>beta确定提取颜色强度时每个斑点的面积。此值通常可以从中获得adata.uns['spatial']。通常，Visium 斑点的大小为 55 到 100</span><mjx-container jax="CHTML" tabindex="0" ctxtmenu_counter="0"><mjx-math aria-hidden="true"><mjx-mi><mjx-c></mjx-c></mjx-mi><mjx-mi><mjx-c></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><mi>μ</mi><mi>m</mi></mjx-assistive-mml></mjx-container><span>。</span></p></li><li><p><span>alpha确定计算斑点间欧几里得距离时赋予组织学图像的权重。alpha=1意味着组织学像素强度值具有与 (x,y) 坐标相同的尺度方差。</span></p></li></ul><section><ul><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="properties"><code><span># Calculate adjacent matrix</span></code><code><span>adj = spg.calculate_adj_matrix(</span></code><code><span>    x=x_pixel,</span></code><code><span>    y=y_pixel,</span></code><code><span>    x_pixel=x_pixel,</span></code><code><span>    y_pixel=y_pixel,</span></code><code><span>    image=img,</span></code><code><span>    beta=55,</span></code><code><span>    alpha=1,</span></code><code><span>    histology=True,</span></code><code><span>)</span></code></pre></section><section><ul><li><li><li></ul><pre data-lang="properties"><code><span>Calculateing adj matrix using histology image...</span></code><code><span>Var of c0,c1,c2 =  96.93674686223055 519.0133178897761 37.20274924909862</span></code><code><span>Var of x,y,z =  2928460.011122931 4665090.578837907 4665090.578837907</span></code></pre></section><section><span>26.4.2.基因表达数据的预处理</span></section><section><span>接下来，我们对基因表达数据执行基本的预处理策略，过滤在少于三个点处表达的基因。此外，对计数进行归一化和对数转换。</span></section><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="cs"><code><span>adata.var_names_make_unique()</span></code><code><span><br></span></code><code><span>sc.pp.filter_genes(adata, min_cells=3)</span></code><code><span><br></span></code><code><span># find mitochondrial (MT) genes</span></code><code><span>adata.var["MT_gene"] = [gene.startswith("MT-") for gene in adata.var_names]</span></code><code><span># remove MT genes (keeping their counts in the object)</span></code><code><span>adata.obsm["MT"] = adata[:, adata.var["MT_gene"].values].X.toarray()</span></code><code><span>adata = adata[:, ~adata.var["MT_gene"].values].copy()</span></code><code><span><br></span></code><code><span># Normalize and take log for UMI</span></code><code><span>sc.pp.normalize_total(adata)</span></code><code><span>sc.pp.log1p(adata)</span></code></pre></section><section><ul><li><li></ul><pre data-lang="css"><code><span>normalizing counts per cell</span></code><code><span>    finished (0:00:00)</span></code></pre></section><h3><span>26.4.3. SpaGCN 的超参数</span></h3><p><span>第一步，SpaGCN 找到特征长度尺度</span><mjx-container jax="CHTML" tabindex="0" ctxtmenu_counter="1"><mjx-math aria-hidden="true"><mjx-mi><mjx-c></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><mi><span>l</span></mi></mjx-assistive-mml></mjx-container><span>。此参数决定权重随距离衰减的速度。为了找到</span><mjx-container jax="CHTML" tabindex="0" ctxtmenu_counter="2"><mjx-math aria-hidden="true"><mjx-mi><mjx-c></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><mi><span>l</span></mi></mjx-assistive-mml></mjx-container><span>，首先必须指定参数</span><mjx-container jax="CHTML" tabindex="0" ctxtmenu_counter="3"><mjx-math aria-hidden="true"><mjx-mi><mjx-c></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><mi><span>p</span></mi></mjx-assistive-mml></mjx-container><span>它描述了邻域对总表达的贡献百分比。对于 Visium 数据，SpaGCN 建议p=0.5。对于像 Slide-seq V2 或 MERFISH 这样的捕获区域较小的数据，建议选择更高的贡献值。</span></p><section><ul><li><li><li></ul><pre data-lang="ini"><code><span>p = 0.5</span></code><code><span># Find the l value given p</span></code><code><span>l = spg.search_l(p, adj)</span></code></pre></section><section><ul><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="properties"><code><span>Run 1: l [0.01, 1000], p [0.0, 176.04695830342547]</span></code><code><span>Run 2: l [0.01, 500.005], p [0.0, 38.50406265258789]</span></code><code><span>Run 3: l [0.01, 250.0075], p [0.0, 7.22906494140625]</span></code><code><span>Run 4: l [0.01, 125.00874999999999], p [0.0, 1.119886875152588]</span></code><code><span>Run 5: l [62.509375, 125.00874999999999], p [0.07394278049468994, 1.119886875152588]</span></code><code><span>Run 6: l [93.7590625, 125.00874999999999], p [0.4443991184234619, 1.119886875152588]</span></code><code><span>Run 7: l [93.7590625, 109.38390625], p [0.4443991184234619, 0.7433689832687378]</span></code><code><span>Run 8: l [93.7590625, 101.571484375], p [0.4443991184234619, 0.5843360424041748]</span></code><code><span>Run 9: l [93.7590625, 97.66527343749999], p [0.4443991184234619, 0.5119975805282593]</span></code><code><span>Run 10: l [95.71216796875, 97.66527343749999], p [0.47760796546936035, 0.5119975805282593]</span></code><code><span>recommended l =  96.688720703125</span></code></pre></section><p><span>如果已知组织中的空间域数量，SpaGCN 可以计算出合适的分辨率来生成相应的数字。例如，在大脑样本中，人们希望在空间幻灯片中找到一定数量的皮质层。如果不知道域的数量，SpaGCN 会将分辨率参数从 0.2 变为 0.1，并使用导致最高 Silhouette 分数的分辨率。</span></p><p><span>我们将簇的数量指定为示例数据集和集合中存在的细胞类型的数量n_clusters=15。</span></p><section><ul><li><li></ul><pre data-lang="ini"><code><span># Search for suitable resolution</span></code><code><span>res = spg.search_res(adata, adj, l, target_num=15)</span></code></pre></section><p><span>现在，我们已经计算了所有必需的参数，可以初始化 SpaGCN 并设置</span><span><mjx-container jax="CHTML" tabindex="0" ctxtmenu_counter="4"><mjx-math aria-hidden="true"><mjx-mi><mjx-c></mjx-c></mjx-mi></mjx-math><mjx-assistive-mml unselectable="on" display="inline"><mi>l</mi></mjx-assistive-mml></mjx-container></span><span><mjx-container jax="CHTML" tabindex="0" ctxtmenu_counter="1"><mjx-assistive-mml unselectable="on" display="inline"><mi>l</mi></mjx-assistive-mml></mjx-container>超参数。</span></p><section><ul><li><li></ul><pre data-lang="makefile"><code><span>model = spg.SpaGCN()</span></code><code><span>model.set_l(l)</span></code></pre></section><p><span>接下来，我们使用适合的分辨率训练模型来识别 15 个空间域。</span></p><section><ul><li></ul><pre><code><span>model.train(adata, adj, res=res)</span></code></pre></section><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="properties"><code><span>Initializing cluster centers with louvain, resolution =  0.65</span></code><code><span>computing neighbors</span></code><code><span>    using data matrix X directly</span></code><code><span>    finished: added to `.uns['neighbors']`</span></code><code><span>    `.obsp['distances']`, distances for each pair of neighbors</span></code><code><span>    `.obsp['connectivities']`, weighted adjacency matrix (0:00:00)</span></code><code><span>running Louvain clustering</span></code><code><span>    using the "louvain" package of Traag (2017)</span></code><code><span>    finished: found 16 clusters and added</span></code><code><span>    'louvain', the cluster labels (adata.obs, categorical) (0:00:00)</span></code><code><span>Epoch  0</span></code><code><span>Epoch  10</span></code><code><span>Epoch  20</span></code><code><span>Epoch  30</span></code><code><span>Epoch  40</span></code><code><span>Epoch  50</span></code><code><span>Epoch  60</span></code><code><span>Epoch  70</span></code><code><span>delta_label  0.000744047619047619 &lt; tol  0.001</span></code><code><span>Reach tolerance threshold. Stopping training.</span></code><code><span>Total epoch: 79</span></code></pre></section><p><span>我们现在预测数据集中每个细胞的相应空间域。此外，该模型返回每个细胞属于其中一个域的概率。我们不会在本教程中利用此信息。</span></p><section><ul><li></ul><pre><code><span>y_pred, prob = model.predict()</span></code></pre></section><p><span>我们现在将空间域保存进去`adata.obs`并将其保存为分类以方便绘图。</span></p><section><ul><li><li></ul><pre data-lang="javascript"><code><span>adata.obs["spaGCN_domains"] = y_pred</span></code><code><span>adata.obs["spaGCN_domains"] = adata.obs["spaGCN_domains"].astype("category")</span></code></pre></section><p><span>让我们在空间散点图中检查结果并将其与数据集中的原始注释进行比较。</span></p><section><ul><li></ul><pre data-lang="javascript"><code><span>sq.pl.spatial_scatter(adata, color=["spaGCN_domains", "cluster"])</span></code></pre></section><p><img data-imgfileid="100000444" data-ratio="0.29205265724037055" data-src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLqCtZ6u5RwGSHF5icyjJgtd6xbdib6524O65jN91bgAz5jQkU2X5ngbSA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="2051" src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLqCtZ6u5RwGSHF5icyjJgtd6xbdib6524O65jN91bgAz5jQkU2X5ngbSA/640?wx_fmt=png&amp;from=appmsg"></p><p><span>我们可以看到，该方法相当准确地识别了空间域。有趣的是，这些域与原始注释非常吻合。然而，我们可以观察到一些异常值，因为一些点仍然分布在数据集中，并且没有被分配到同一个域。SpaGCN 提供了一个细化空间域的功能，我们现在将展示它。</span></p><h3><span>26.4.4.细化检测到的空间域</span></h3><p><span>SpaGCN 包含一个可选的细化步骤来增强聚类结果，该步骤检查每个点及其相邻点的域分配。如果超过一半的相邻点被分配到不同的域，则该点将被重新标记为其相邻点的主域。细化步骤只会影响少数点。通常，SpaGCN 仅在预期数据集具有清晰的域边界时才建议进行细化。</span></p><p><span>为了进行细化，SpaGCN 首先计算了不考虑组织学图像的邻接矩阵。</span></p><section><ul><li></ul><pre data-lang="ini"><code><span>adj_2d = spg.calculate_adj_matrix(x=x_array, y=y_array, histology=False)</span></code></pre></section><section><ul><li></ul><pre data-lang="cs"><code><span>Calculateing adj matrix using xy only...</span></code></pre></section><p><span>现在，这个邻接矩阵与之前计算的域一起用于细化。</span><span></span></p><section><ul><li><li><li><li><li></ul><pre data-lang="properties"><code><span>refined_pred = spg.refine(</span></code><code><span>    sample_id=adata.obs.index.tolist(),</span></code><code><span>    pred=adata.obs["spaGCN_domains"].tolist(),</span></code><code><span>    dis=adj_2d,</span></code><code><span>)</span></code></pre></section><p><span>我们现在将细化的空间域保存进去`adata.obs`，并将其保存为分类，以方便绘图。</span><span></span></p><section><ul><li><li><li><li></ul><pre data-lang="javascript"><code><span>adata.obs[<span>"refined_spaGCN_domains"</span>] = refined_pred</span></code><code><span>adata.obs[<span>"refined_spaGCN_domains"</span>] = adata.obs[<span>"refined_spaGCN_domains"</span>].astype(</span></code><code><span>    <span>"category"</span></span></code><code><span>)</span></code></pre></section><p><span>让我们检查一下与原始空间域相比经过细化的空间域。</span></p><section><ul><li></ul><pre data-lang="javascript"><code><span>sq.pl.spatial_scatter(adata, color=["refined_spaGCN_domains", "spaGCN_domains"])</span></code></pre></section><p><img data-imgfileid="100000445" data-ratio="0.423321554770318" data-src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLOfLpEX5tibsxUnKibTicAeiauuibiagY8sSASMVv6vWDNpptDW6t7hX2m7Pw/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1415" src="https://mmbiz.qpic.cn/mmbiz_png/e1cKg2SPUFia95ia4k0icD9y5wfXxjd9ibMLOfLpEX5tibsxUnKibTicAeiauuibiagY8sSASMVv6vWDNpptDW6t7hX2m7Pw/640?wx_fmt=png&amp;from=appmsg"></p><p><span>我们可以看到，经过精炼的空间域没有显示异常值，但不同域之间的边界清晰。下一步，现在可以注释已识别的空间域或使用它们来计算空间可变基因。</span><span></span></p><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/-BhEdIM6mGJCaPOm1c7YSg",target="_blank" rel="noopener noreferrer">原文链接</a>
