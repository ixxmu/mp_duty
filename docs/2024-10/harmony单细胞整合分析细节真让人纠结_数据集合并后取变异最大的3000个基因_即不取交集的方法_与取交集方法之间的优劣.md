---
title: "harmony单细胞整合分析细节真让人纠结：数据集合并后取变异最大的3000个基因（即不取交集的方法）与取交集方法之间的优劣"
date: 2024-10-03T09:33:47Z
draft: ["false"]
tags: [
  "fetched",
  "生信小博士"
]
categories: ["Acdemic"]
---
harmony单细胞整合分析细节真让人纠结：数据集合并后取变异最大的3000个基因（即不取交集的方法）与取交集方法之间的优劣 by 生信小博士
------
<div><h3><span><br></span></h3><h3><span>01单细胞整合分析的目的</span></h3><h3><span>不同的单细胞整合方式都是为了最后的<span>FindNeighbors、FindClusters()</span>两步，得到聚类信息，进行细胞命名，然后单细胞整合的任务就完成了。</span><span>（<span>其他的所有分析都是基于分好的亚群基础上进行的。和整合</span><strong>之后</strong><span>获取的data矩阵和scale.data矩阵关系不大。这句话不太对，容易引起误会</span><span>）</span></span></h3><hr><h3></h3><section><ul><li><li><li><li><li><li><li><li><li></ul><pre data-lang="nginx"><code><span>    注意：SCTransform不能去除批次效应</span></code><code><span>    <span>visium_slide</span> = visium_slide %&gt;%</span></code><code><span>      PercentageFeatureSet(pattern = <span>"^Mt-"</span>, col.name = <span>"percent.mt"</span>) %&gt;%</span></code><code><span>      PercentageFeatureSet(pattern = <span>"^Hb-"</span>, col.name = <span>"percent.hb"</span>) %&gt;%</span></code><code><span>      PercentageFeatureSet(pattern = <span>"^RP[LS]"</span>, col.name = <span>"percent.ribo"</span>) %&gt;%</span></code><code><span><br></span></code><code><span>      SCTransform(assay = <span>"RNA"</span>,vars.to.regress = c(<span>"percent.mt"</span>,<span>"percent.ribo"</span>,<span>"percent.hb"</span>)) %&gt;%</span></code><code><span>      RunPCA() %&gt;%     RunUMAP(dims = <span>1</span>:<span>30</span>) %&gt;%</span></code><code><span>      FindNeighbors(dims = <span>1</span>:<span>30</span>) %&gt;%  FindClusters()</span></code></pre></section><hr><h3><span></span></h3><p><span><strong><br></strong></span></p><p><span><strong>开头一段话种需要澄清和扩展的地方：</strong></span></p><h3>1. <strong>整合分析的目标</strong></h3><p>单细胞RNA测序的整合分析主要目的是对来自不同实验条件、时间点或技术平台的细胞进行整合，使得这些细胞可以在一个统一的空间中进行比较。<span><strong>整合分析的两个主要目标是：</strong></span></p><ul><li><p><strong>消除批次效应</strong>: 通过整合分析减少不同实验条件或平台之间的技术性差异（批次效应），使得来自不同来源的相似细胞可以更好地对齐。</p></li><li><p><strong>揭示细胞亚群</strong>: 通过聚类分析识别不同的细胞亚群，并为这些亚群进行命名，赋予生物学意义。</p><p><br></p></li></ul><h3>2. <strong>整合后的数据矩阵（data矩阵和scale.data矩阵）</strong></h3><p>整合之后得到的<code>data</code>矩阵和<code>scale.data</code>矩阵，虽然不直接用于后续的某些分析（如差异表达分析等），但它们在整合过程和后续的特定类型的分析中仍然具有重要作用：</p><ul><li><p><strong>data矩阵</strong>: 通常表示的是归一化后的表达值，这些值可以用于后续的基因表达模式分析、差异表达分析等。</p></li><li><p><strong>scale.data矩阵</strong>: 在整合分析中，<span><strong><code>scale.data</code>矩阵用于PCA和聚类分析。这些分析帮助你识别和定义细胞亚群。因此，整合后的<code>scale.data</code>矩阵和聚类信息之间存在直接关系。</strong></span></p></li></ul><h3>3. <strong>聚类和细胞命名</strong></h3><p>确实，聚类分析和细胞亚群命名是整合分析的关键步骤之一，这为后续的所有分析奠定了基础。所有其他的生物学分析，如差异表达分析、功能富集分析等，都是基于这些聚类信息进行的。因此，准确的聚类和命名对于后续分析至关重要。</p><h3>4. <strong>整合分析后的用途</strong></h3><p>虽然整合后的数据矩阵和<code>scale.data</code>矩阵不直接用于某些后续分析，但它们仍然在以下几个方面具有重要作用：</p><ul><li><p><strong>维度缩减和可视化</strong>: UMAP、t-SNE等方法依赖于整合后的数据矩阵或其衍生物，用于在低维空间中可视化细胞分布。</p></li><li><p><strong>整合数据的一致性验证</strong>: 整合后的矩阵可以用于评估整合效果，验证不同数据集之间的细胞是否有效对齐，是否消除了批次效应。</p></li><li><p><strong>整合模型的生成</strong>: 这些矩阵可以作为生成整合模型的基础，这些模型可以用来整合新的数据集，或在不同的分析中重复使用。</p></li></ul><h3>5. <strong>总结</strong></h3><ul><li><p><strong>聚类信息和细胞命名</strong>: 是整合分析的核心目标，后续分析确实依赖于这一信息。</p></li><li><p><strong>整合后的数据矩阵</strong>: 虽然在某些分析中不直接使用，但它们在整合过程、可视化、模型生成等方面起到重要作用。</p><hr><p><br></p></li></ul><p><span><br></span></p><h3><span>02如何让单细胞整合分析的umap图更好看</span></h3><p><span></span></p><p><span>如果仅仅为了自己的umap图好看，甚至可以自己选择或者指定高边基因：<a target="_blank" href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247533646&amp;idx=1&amp;sn=856149a09714e5b38d4aa3b4a566a07f&amp;chksm=9b4b04f5ac3c8de3b9b3e736376ae9ffd81dc40bf790b64490b993bed62f7f3688cac52e199a&amp;scene=21#wechat_redirect" textvalue="不是造假胜似造假的单细胞降维聚类分群" linktype="text" imgurl="" imgdata="null" data-itemshowtype="0" tab="innerlink" data-linktype="2">不是造假胜似造假的单细胞降维聚类分群</a><br></span></p><p>在单细胞转录组数据整合分析中，使用特定的基因集（如<code>gene_selection</code>）作为PCA的输入，而不是直接使用所有基因进行PCA，有几个原因：</p><h3>1. <strong>数据降维和噪声处理</strong>:</h3><ul><li><p>单细胞转录组数据通常包含大量的噪声和冗余信息。如果直接使用所有基因进行PCA，可能会引入不相关或噪声信号，影响PCA的效果。通过选择高变异基因（HVGs）或特定的基因集（如<code>gene_selection</code>），可以集中在那些在细胞类型之间差异最大的基因，从而更好地揭示细胞间的异质性。</p></li></ul><h3>2. <strong>提高计算效率</strong>:</h3><ul><li><p>使用所有基因进行PCA计算量巨大，尤其是在大规模数据集中。通过预先选择少量具有生物学意义的基因，减少数据的维度，可以显著提高PCA的计算效率，并减少内存使用。</p></li></ul><h3>3. <strong>保留生物学意义</strong>:</h3><ul><li><p>选取的基因集往往包含那些与特定生物学过程或细胞类型相关的基因，这样做能够更好地保留这些生物学信息，从而在后续分析中（如聚类、UMAP、Harmony整合）中，获得更可靠的结果。</p></li></ul><h3>4. <strong>增强整合效果</strong>:</h3><ul><li><p>在多样本或多批次数据整合中，使用特定的基因集进行PCA，并结合Harmony等批次效应去除工具，有助于增强整合的效果，使得来自不同样本的细胞类型能够更好地对齐，而不受批次效应的干扰。</p></li></ul><hr><p><br></p><p>在代码片段中，通过<code>FindVariableFeatures</code>选取3000个变异最大的基因，形成<code>gene_selection</code>，并在PCA时使用这些基因作为输入。这样做有助于将焦点集中在数据中最具信息量的部分，从而提高分析的效果和效率。</p><p>相比之下，直接使用所有基因进行PCA，可能会导致计算冗余、噪声干扰，并降低整合的效果，这也是为什么要选择特定基因集作为PCA输入的主要原因。</p><p><span><br></span></p><h3><span>03 整合分析前，是否需要对所有数据集取交集</span></h3><p><span><br></span></p><h3><span></span></h3><h3><span>1. <strong>不取交集的方法（合并后选择整体变异最大的3000个基因）</strong></span></h3><h4><strong>优点</strong>:</h4><ul><li><p><strong>综合考虑所有数据集的变异性</strong>: 通过将所有数据集合并后再选择变异最大的3000个基因，这种方法能够综合考虑所有样本的变异性，从而确保所选择的基因在整个数据集中具有高变异性。这可以捕捉到所有数据集之间共享的主要生物学信号。</p></li><li><p><strong>最大化信息利用</strong>: 这种方法利用了整个数据集的完整信息，确保在选择高变异基因时没有遗漏任何在个别样本中表现显著的基因。</p></li><li><p><strong>简化数据处理流程</strong>: 只需对合并后的数据集进行一次高变异基因选择，减少了在不同数据集上重复选择的工作量，同时确保所有数据集的一致性。</p></li></ul><h4><strong>缺点</strong>:</h4><ul><li><p><strong>可能偏向大样本量数据集</strong>: <span>在合并数据集中，大样本量的数据集可能会对基因变异性的计算产生更大影响，导致选择的基因更偏向于这些数据集，从而忽略了小样本量数据集中可能同样重要的基因。</span></p></li><li><p><span><strong>潜在的批次效应影响</strong>: 如果不同数据集之间存在显著的批次效应，这种方法可能会导致批次效应在选择高变异基因时的作用被放大，从而在整合分析中引入偏差。</span></p></li></ul><p><br></p><h3><span><strong><span>2. 取交集的方法（从每个数据集各自的高变异基因中取交集）</span></strong></span></h3><h4><strong>优点</strong>:</h4><ul><li><p><strong>减少批次效应的影响</strong>: 通过从每个数据集的高变异基因中取交集，确保只使用在所有数据集中都表现出高变异的基因，<span><strong>从而减少了批次效应对整合分析的影响。</strong></span></p></li><li><p><strong>提高数据一致性</strong>: 使用的基因集合在所有数据集中一致，这有助于在整合分析中获得更加稳健和一致的结果，特别是在对齐细胞类型和去除批次效应时。</p></li></ul><h4><strong>缺点</strong>:</h4><ul><li><p><strong><span>信息丢失: 取交集方法可能会排除那些在某些数据集中重要但在其他数据集中没有表现出显著变异的基因，导致潜在的生物学信息丢失，尤其是在数据集之间存在生物学差异的情况下</span></strong>。</p></li><li><p><strong>基因集大小受限</strong>: 交集往往会导致基因集合的缩小，特别是在数据集之间差异较大时。这可能会降低PCA和后续分析的维度，进而影响分析的全面性和深度。</p></li></ul><h3>总结</h3><ul><li><p><span><strong>不取交集</strong>: 适用于希望最大限度地利用所有数据集的整体变异信息时，但需要注意可能引入批次效应和偏向大样本量数据集的风险。</span></p><p><br></p></li><li><p><strong>取交集</strong>: 适用于希望在多数据集整合中减少批次效应并提高分析结果一致性时，但可能会丢失一些特定数据集中的重要基因信息。</p></li></ul><p>最终，选择哪种方法取决于你对批次效应的敏感度、数据集的规模和多样性，以及对全面生物学信息保留的需求。</p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="php"><code><span><span>#取交集进行整合分析的完整代码</span></span></code><code><span>All.merge=SCTransform(All.merge, verbose = <span>FALSE</span>)  %&gt;% RunPCA(npcs = <span>30</span>, verbose = <span>FALSE</span>)</span></code><code><span>library(<span>'harmony'</span>)</span></code><code><span>All.merge &lt;- All.merge  %&gt;% RunHarmony(<span>"stim"</span>, plot_convergence = <span>TRUE</span>)</span></code><code><span>harmony_embeddings &lt;- Embeddings(All.merge , <span>'harmony'</span>) </span></code><code><span><span>#######################cluster</span></span></code><code><span>dims = <span>1</span>:<span>30</span></span></code><code><span>All.merge  &lt;- All.merge  %&gt;% </span></code><code><span>  RunUMAP(reduction = <span>"harmony"</span>, dims = dims) %&gt;% </span></code><code><span>  RunTSNE(reduction = <span>"harmony"</span>, dims = dims) %&gt;% </span></code><code><span>  FindNeighbors(reduction = <span>"harmony"</span>, dims = dims)</span></code><code><span>                       使用gene_selection作为pca的输入的代码 ：<span>#####安装archr包##别处复制</span></span></code><code><span>.libPaths(c(<span>"/home/data/t040413/R/x86_64-pc-linux-gnu-library/4.2"</span>,</span></code><code><span>            <span>"/home/data/t040413/R/yll/usr/local/lib/R/site-library"</span>, </span></code><code><span>            <span>"/usr/local/lib/R/library"</span>,</span></code><code><span>            <span>"/home/data/refdir/Rlib/"</span>))</span></code><code><span><br></span></code><code><span>.libPaths()</span></code><code><span>library(tidyverse)</span></code><code><span>library(Seurat)</span></code><code><span>library(optparse)</span></code><code><span>library(scater)</span></code><code><span>library(harmony)</span></code><code><span>library(dplyr)</span></code><code><span>library(optparse)</span></code><code><span>library(tidyverse)</span></code><code><span>library(Seurat)</span></code><code><span>library(harmony)</span></code><code><span>library(cluster)</span></code><code><span>library(clustree)</span></code><code><span><span>#https://github.com/saezlab/visium_heart/blob/5b30c7e497e06688a8448afd8d069d2fa70ebcd2/st_snRNAseq/02_snuc_integration_harmony/integrate_objects.R#L194</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>slide_files &lt;- <span>list</span>.files(<span>"~/silicosis/spatial/prcessed_visum_for_progeny/data/"</span>,recursive = <span>TRUE</span>,</span></code><code><span>                                        all.files = <span>TRUE</span>,full.names = <span>TRUE</span>,pattern = <span>"_"</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>integrated_data &lt;- map(slide_files, readRDS)</span></code><code><span><span>print</span>(<span>"You managed to load everything"</span>)</span></code><code><span><span>print</span>(<span>"Object size"</span>)</span></code><code><span><span>print</span>(object.size(integrated_data))</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Calculate HVG per sample - Here we assume that batch and patient effects aren't as strong</span></span></code><code><span><span># since cell-types and niches should be greater than the number of batches</span></span></code><code><span><br></span></code><code><span>Assays(integrated_data [[<span>1</span>]])</span></code><code><span>str(integrated_data [[<span>1</span>]])</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>def_assay=<span>"Spatial"</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span>hvg_list &lt;- map(integrated_data, <span><span>function</span><span>(x)</span> </span>{</span></code><code><span>  </span></code><code><span>  DefaultAssay(x) &lt;- def_assay</span></code><code><span>  </span></code><code><span>  x &lt;- FindVariableFeatures(x, selection.method = <span>"vst"</span>, </span></code><code><span>                            nfeatures = <span>3000</span>)</span></code><code><span>  </span></code><code><span>  x@assays[[def_assay]]@<span>var</span>.features</span></code><code><span>  </span></code><code><span>}) %&gt;% unlist()</span></code><code><span><br></span></code><code><span>hvg_list &lt;- table(hvg_list) %&gt;%</span></code><code><span>  sort(decreasing = <span>TRUE</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span>gene_selection_plt &lt;- hvg_list %&gt;% enframe() %&gt;% </span></code><code><span>  group_by(value) %&gt;% </span></code><code><span>  mutate(value = <span>as</span>.numeric(value)) %&gt;%</span></code><code><span>  summarize(ngenes = length(name)) %&gt;% </span></code><code><span>  ggplot(aes(x = value, y = ngenes)) + </span></code><code><span>  geom_bar(stat = <span>"identity"</span>)</span></code><code><span><br></span></code><code><span>gene_selection &lt;- hvg_list[<span>1</span>:<span>3000</span>] %&gt;% names()</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>#########</span></span></code><code><span><span># Create merged object ---------------------------------</span></span></code><code><span>integrated_data &lt;- purrr::reduce(integrated_data,</span></code><code><span>                          merge,</span></code><code><span>                          merge.data = <span>TRUE</span>)</span></code><code><span><br></span></code><code><span><span>print</span>(<span>"You managed to merge everything"</span>)</span></code><code><span><span>print</span>(<span>"Object size"</span>)</span></code><code><span><span>print</span>(object.size(integrated_data))</span></code><code><span><br></span></code><code><span><span># Default assay ---------------------------------------</span></span></code><code><span><span>#DefaultAssay(integrated_data) &lt;- def_assay</span></span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span># Process it before integration -----------------------</span></span></code><code><span>integrated_data &lt;- integrated_data %&gt;%</span></code><code><span>  ScaleData(verbose = <span>FALSE</span>) %&gt;% </span></code><code><span>  RunPCA(features = gene_selection, </span></code><code><span>         npcs = <span>30</span>, </span></code><code><span>         verbose = <span>FALSE</span>) </span></code><code><span><br></span></code><code><span>original_pca_plt &lt;- DimPlot(object = integrated_data, </span></code><code><span>                            reduction = <span>"pca"</span>, </span></code><code><span>                            pt.size = <span>.1</span>, </span></code><code><span>                            group.by = <span>"orig.ident"</span>)</span></code><code><span><br></span></code><code><span>head(integrated_data@meta.data)</span></code><code><span><br></span></code><code><span>batch_covars=<span>"orig.ident"</span></span></code><code><span><span># Integrate the data -----------------------</span></span></code><code><span>integrated_data &lt;- RunHarmony(integrated_data, </span></code><code><span>                              group.by.vars =   batch_covars, </span></code><code><span>                              plot_convergence = <span>TRUE</span>,</span></code><code><span>                              assay.<span>use</span> = def_assay,</span></code><code><span>                              max.iter.harmony = <span>20</span>)</span></code><code><span><br></span></code></pre></section><section><mp-common-profile data-pluginname="mpprofile" data-id="Mzg2NDcxMzYwNg==" data-headimg="http://mmbiz.qpic.cn/sz_mmbiz_png/xVhD7345Sks7JhVxUX46ZKxPSob6ptqIZgnIEnHOn5VMwCX8sN6MQy1Pq4XXFEOJ6grAmsoQugyCDKOZictDBHA/0?wx_fmt=png" data-nickname="生信小博士" data-alias="bioinformatics_Dr" data-signature="【生物信息学】R语言开始，学习生信。Seurat，单细胞测序，空间转录组。 Python，scanpy，cell2location。资料分享" data-from="0" data-is_biz_ban="0"></mp-common-profile></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/M8q1WZ8dgcWYwVWcT-iYAA",target="_blank" rel="noopener noreferrer">原文链接</a>
