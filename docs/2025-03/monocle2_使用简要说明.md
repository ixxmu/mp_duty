---
title: "monocle2 使用简要说明"
date: 2025-03-26T11:11:46Z
draft: ["false"]
tags: [
  "fetched",
  "生信小知识"
]
categories: ["Acdemic"]
---
monocle2 使用简要说明 by 生信小知识
------
<div><section data-pm-slice="0 0 []"><h2><span><span leaf="">monocle2 使用简要说明</span></span></h2><blockquote><p><span leaf="">微信公众号：</span><strong><span leaf="">生信小知识</span></strong><span leaf=""><br></span><span leaf="">关注可了解更多的生物信息学教程及知识。问题或建议，请公众号留言;</span></p></blockquote><h3><span><span leaf="">目录</span></span></h3><p><span><span><span leaf="">前言</span></span></span><span><span><span leaf="">1. 软件安装</span></span></span><span><span><span leaf="">2. 数据预处理</span></span></span><span><span><span><span leaf="">2.1 创建cds对象</span></span></span></span><span><span><span><span leaf="">2.2 选择数据的分布</span></span></span></span><span><span><span><span leaf="">2.3 将 TPM/FPKM 值转换为 count 计数</span></span></span></span><span><span><span leaf="">3. 计算 SizeFactors 和 Dispersions</span></span></span><span><span><span leaf="">4. 过滤低质量数据</span></span></span><span><span><span leaf="">5. 细胞分群注释</span></span></span><span><span><span leaf="">6. 构建单细胞轨迹</span></span></span><span><span><span><span leaf="">6.1 选择决定过程的基因</span></span></span></span><span><span><span><span leaf="">6.2 减少数据的维度</span></span></span></span><span><span><span><span leaf="">6.3 在伪时间中对细胞排序</span></span></span></span><span><span><span leaf="">后记</span></span></span></p><h3><span><span leaf="">前言</span></span></h3><p><span leaf="">最近对monocle2的使用和算法有些兴趣，这里在查阅后官网信息后做一个简单整理，以备后用。这里顺便放上多年前我写的笔记（有些啰嗦的笔记）：</span></p><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTk0Mzg2Nw==&amp;mid=2247483903&amp;idx=1&amp;sn=ffa4382cd7065b5b07067ec9a451081d&amp;scene=21#wechat_redirect"><span leaf="">Monocle3学习笔记——1</span></a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5NTk0Mzg2Nw==&amp;mid=2247484069&amp;idx=1&amp;sn=d1ffe7710544a15d731db14c03db5e56&amp;scene=21#wechat_redirect"><span leaf="">Monocle3学习笔记——2</span></a></p></li></ul><p><span leaf="">这次的资料来自：https://cole-trapnell-lab.github.io/monocle-release/docs/</span></p><p><span leaf="">简单来说，在单细胞数据中，每个细胞数据都只是当时取材时转录表达水平的一个快照，Monocle通过细胞间表达水平的相似性，利用不同细胞在整个发育过程中的异步进展，引入了</span><strong><span leaf="">伪时间</span></strong><span leaf="">的概念，对所有细胞进行排序，将它们沿着与细胞分化等生物过程相对应的轨迹放置。其主要原理依赖于Reversed Graph Embedding。</span></p><h3><span><span leaf="">1. 软件安装</span></span></h3><pre><code><span leaf="">BiocManager::install(</span><span><span leaf="">"monocle"</span></span><span leaf="">, ask = </span><span><span leaf="">F</span></span><span leaf="">, update = </span><span><span leaf="">F</span></span><span leaf="">)</span><span leaf=""><br></span></code></pre><h3><span><span leaf="">2. 数据预处理</span></span></h3><h4><span><span leaf="">2.1 创建cds对象</span></span></h4><p><span leaf="">Monocle 将单个细胞表达数据保存在 </span><code><span leaf="">CellDataSet</span></code><span leaf=""> 类的对象中，该类需要三个输入文件：</span></p><ul><li><code><span leaf="">exprs</span></code><section><span leaf="">：表达值的数字矩阵，其中行是基因，列是细胞</span></section></li><li><code><span leaf="">phenoData</span></code><section><span leaf="">：一个 </span><code><span leaf="">AnnotatedDataFrame</span></code><span leaf=""> 对象，其中行是细胞，列是细胞属性，如细胞类型、培养条件、捕获日期等</span></section></li><li><code><span leaf="">featureData</span></code><section><span leaf="">：一个 </span><code><span leaf="">AnnotatedDataFrame</span></code><span leaf=""> 对象，其中行是特征（例如基因），列是基因属性，例如GC含量等</span></section></li></ul><p><span leaf="">我们可以用下面的方式创建 </span><code><span leaf="">CellDataSet</span></code><span leaf=""> 对象：</span></p><pre><code><span><span leaf=""># 创建数据</span></span><span leaf=""><br></span><span><span leaf="">library</span></span><span leaf="">(monocle)</span><span leaf=""><br></span><span><span leaf="">library</span></span><span leaf="">(SeuratData)</span><span leaf=""><br></span><span leaf="">pbmc &lt;- LoadData(</span><span><span leaf="">"pbmc3k.SeuratData"</span></span><span leaf="">)</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">exprs &lt;- as(as.matrix(pbmc@assays$RNA$counts), </span><span><span leaf="">'sparseMatrix'</span></span><span leaf="">)</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">featureData &lt;- data.frame(gene_short_name = row.names(pbmc),row.names = row.names(pbmc))</span><span leaf=""><br></span><span leaf="">fd &lt;- new(</span><span><span leaf="">'AnnotatedDataFrame'</span></span><span leaf="">, data = featureData)</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">phenoData &lt;- pbmc@meta.data</span><span leaf=""><br></span><span leaf="">colnames(phenoData)[</span><span><span leaf="">4</span></span><span leaf="">] &lt;- </span><span><span leaf="">"celltype"</span></span><span leaf=""><br></span><span leaf="">pd &lt;- new(</span><span><span leaf="">'AnnotatedDataFrame'</span></span><span leaf="">, data = phenoData)</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">HSMM &lt;- newCellDataSet(exprs,</span><span leaf=""><br></span><span leaf="">                       phenoData = pd, </span><span leaf=""><br></span><span leaf="">                       featureData = fd,</span><span leaf=""><br></span><span leaf="">                       lowerDetectionLimit = </span><span><span leaf="">0.5</span></span><span leaf="">,</span><span leaf=""><br></span><span leaf="">                       expressionFamily = negbinomial.size())</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">rm(list = ls()[ls() != </span><span><span leaf="">"HSMM"</span></span><span leaf="">])</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">HSMM$celltype &lt;- ifelse(is.na(HSMM$celltype), </span><span><span leaf="">"NA"</span></span><span leaf="">, HSMM$celltype)</span><span leaf=""><br></span></code></pre><p><span leaf="">monocle</span><strong><span leaf="">默认你读入的是count矩阵</span></strong><span leaf="">，所以在做差异分析时，会默认将数据分布呈现为</span><strong><span leaf="">负二项分布</span></strong><span leaf="">。如果是RPKM矩阵、TPM矩阵，则后面需要注意修改部分参数。</span></p><blockquote><p><span leaf="">注意：如果数据是count矩阵，不要自己去normalization处理为RPKM或者TPM，要先创建为monocle对象，后用monocle自带函数去normalization。</span></p></blockquote><h4><span><span leaf="">2.2 选择数据的分布</span></span></h4><p><span leaf="">monocle处理count矩阵最佳，但是无论你的数据是count矩阵、RPKM矩阵，或者TPM矩阵，都需要我们去指定一个数据分布：</span></p><ul><li><p><span leaf="">RPKM矩阵和TPM矩阵：log-normally distributed</span></p></li><li><p><strong><span leaf="">count矩阵：负二项分布</span></strong><span leaf="">（negative binomial）</span></p></li></ul><pre><code><span><span leaf=""># 针对count矩阵：</span></span><span leaf=""><br></span><span leaf="">HSMM &lt;- newCellDataSet(count_matrix,</span><span leaf=""><br></span><span leaf="">                phenoData = pd,</span><span leaf=""><br></span><span leaf="">                featureData = fd,</span><span leaf=""><br></span><span leaf="">                expressionFamily=negbinomial.size())</span><span leaf=""><br></span></code></pre><p><span leaf="">关于参数</span><code><span leaf="">expressionFamily</span></code><span leaf="">，需要注意这</span><strong><span leaf="">依赖于VGAM package</span></strong><span leaf="">，可供选择的选项有：</span></p><ul><li><section><span leaf="">negbinomial.size()——count矩阵，</span><strong><span leaf="">推荐大多数情况使用</span></strong></section></li><li><section><span leaf="">negbinomial()——count矩阵，更加准确，但是速度更慢，</span><strong><span leaf="">推荐小数据集使用</span></strong></section></li><li><section><span leaf="">tobit()——FPKM、TPM矩阵，</span><strong><span leaf="">一般来说推荐使用</span></strong><span leaf="">，但是如果要求更高可以使用</span><code><span leaf="">relative2abs()</span></code><span leaf="">函数</span></section></li></ul><p><code><span leaf="">expressionFamily</span></code><span leaf=""> 有几个允许的值，它需要VGAM包中的“family function”：</span></p><table><thead><tr><th><section><span leaf="">Family function</span></section></th><th><section><span leaf="">Data type</span></section></th><th><section><span leaf="">Notes</span></section></th></tr></thead><tbody><tr><td><code><span leaf="">negbinomial.size()</span></code></td><td><section><span leaf="">Raw counts</span></section></td><td><section><span leaf="">具有固定方差的负二项分布，推荐给大多数用户</span></section></td></tr><tr><td><code><span leaf="">negbinomial()</span></code></td><td><section><span leaf="">Raw counts</span></section></td><td><section><span leaf="">比 </span><code><span leaf="">negbinomial.size()</span></code><span leaf=""> 稍微准确一点，但是很慢，不建议使用，除非数据集非常小</span></section></td></tr><tr><td><code><span leaf="">tobit()</span></code></td><td><section><span leaf="">FPKM, TPM</span></section></td><td><section><span leaf="">Tobits是截断的正态分布，可以在使用过程中进行log-transform，不要自己进行log-transform</span></section></td></tr><tr><td><code><span leaf="">gaussianff()</span></code></td><td><section><span leaf="">log-transformed FPKM/TPMs</span></section></td><td><section><span leaf="">在已经转换为正态分布的数据上使用 Monocle，你可以使用这个函数，一般不推荐</span></section></td></tr></tbody></table><blockquote><p><span leaf="">对于 FPKM/TPM 数据，我们仍然可以使用负二项，前提是首先使用 </span><code><span leaf="">relative2abs()</span></code><span leaf=""> 将相对表达值转换为 count 计数。这通常会导致比直接使用 </span><code><span leaf="">tobit()</span></code><span leaf=""> 更准确。具体见下。</span></p></blockquote><h4><span><span leaf="">2.3 将 TPM/FPKM 值转换为 count 计数</span></span></h4><p><span leaf="">对于有spike-in的样本，可以计算mRNAs per cell （RPC）值来当做normalization，RPC 值通常比 FPKM 或 TPM 值更容易分析，因为有更好的统计工具来建模它们。即使实验中不包括spike-in，我们也可以将 FPKM 或 TPM 值转换为 RPC 值。Monocle 2 包括一个名为 Census 的算法，可以执行这种转换。</span></p><p><span leaf="">monocle可以通过函数 </span><code><span leaf="">relative2abs()</span></code><span leaf=""> 来达到目的，转化为RPC值矩阵：</span></p><pre><code><span><span leaf=""># First create a CellDataSet from the relative expression levels</span></span><span leaf=""><br></span><span leaf="">HSMM &lt;- newCellDataSet(as.matrix(HSMM_expr_matrix),</span><span leaf=""><br></span><span leaf="">                phenoData = pd,</span><span leaf=""><br></span><span leaf="">                featureData = fd,</span><span leaf=""><br></span><span leaf="">                lowerDetectionLimit = </span><span><span leaf="">0.1</span></span><span leaf="">, </span><span><span leaf=""># 这里的cutoff是0.1，可以根据需求自行设定</span></span><span leaf=""><br></span><span leaf="">                expressionFamily = tobit(Lower = </span><span><span leaf="">0.1</span></span><span leaf="">)) </span><span><span leaf=""># 这里的cutoff是0.1，可以根据需求自行设定</span></span><span leaf=""><br></span><span leaf=""><br></span><span><span leaf=""># Next, use it to estimate RNA counts</span></span><span leaf=""><br></span><span leaf="">rpc_matrix &lt;- relative2abs(HSMM, method = </span><span><span leaf="">"num_genes"</span></span><span leaf="">)</span><span leaf=""><br></span><span leaf=""><br></span><span><span leaf=""># Now, make a new CellDataSet using the RNA counts</span></span><span leaf=""><br></span><span leaf="">HSMM &lt;- newCellDataSet(as(as.matrix(rpc_matrix), </span><span><span leaf="">"sparseMatrix"</span></span><span leaf="">),</span><span leaf=""><br></span><span leaf="">                phenoData = pd,</span><span leaf=""><br></span><span leaf="">                featureData = fd,</span><span leaf=""><br></span><span leaf="">                lowerDetectionLimit = </span><span><span leaf="">0.5</span></span><span leaf="">,</span><span leaf=""><br></span><span leaf="">                expressionFamily = negbinomial.size()) </span><span><span leaf=""># 更换为负二项分布</span></span><span leaf=""><br></span></code></pre><h3><span><span leaf="">3. 计算 SizeFactors 和 Dispersions</span></span></h3><ul><li><p><span leaf="">SizeFactors用来normalization数据。</span></p></li><li><p><span leaf="">Dispersion在后面差异分析时使用。</span></p></li></ul><pre><code><span leaf="">HSMM &lt;- estimateSizeFactors(HSMM)</span><span leaf=""><br></span><span leaf="">HSMM &lt;- estimateDispersions(HSMM)</span><span leaf=""><br></span></code></pre><h3><span><span leaf="">4. 过滤低质量数据</span></span></h3><p><span leaf="">检查基因在多少细胞数中表达，过滤低于在1%细胞中检出的基因 ：</span></p><pre><code><span leaf="">HSMM &lt;- detectGenes(HSMM, min_expr = </span><span><span leaf="">0.1</span></span><span leaf="">)</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">print(head(fData(HSMM)))</span><span leaf=""><br></span><span><span leaf="">##               gene_short_name num_cells_expressed</span></span><span leaf=""><br></span><span><span leaf="">## AL627309.1         AL627309.1                   9</span></span><span leaf=""><br></span><span><span leaf="">## AP006222.2         AP006222.2                   3</span></span><span leaf=""><br></span><span><span leaf="">## RP11-206L10.2   RP11-206L10.2                   5</span></span><span leaf=""><br></span><span><span leaf="">## RP11-206L10.9   RP11-206L10.9                   3</span></span><span leaf=""><br></span><span><span leaf="">## LINC00115           LINC00115                  18</span></span><span leaf=""><br></span><span><span leaf="">## NOC2L                   NOC2L                 258</span></span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">print(head(pData(HSMM)))</span><span leaf=""><br></span><span><span leaf="">##                orig.ident nCount_RNA nFeature_RNA celltype Size_Factor num_genes_expressed</span></span><span leaf=""><br></span><span><span leaf="">## AAACATACAACCAC     pbmc3k       2419          779        2   1.1204557                 779</span></span><span leaf=""><br></span><span><span leaf="">## AAACATTGAGCTAC     pbmc3k       4903         1352        4   2.2710187                1352</span></span><span leaf=""><br></span><span><span leaf="">## AAACATTGATCAGC     pbmc3k       3147         1129        2   1.4576577                1129</span></span><span leaf=""><br></span><span><span leaf="">## AAACCGTGCTTCCG     pbmc3k       2639          960        3   1.2223574                 960</span></span><span leaf=""><br></span><span><span leaf="">## AAACCGTGTATGCG     pbmc3k        980          521        7   0.4539258                 521</span></span><span leaf=""><br></span><span><span leaf="">## AAACGCACTGGTAC     pbmc3k       2163          781        2   1.0018791                 781</span></span><span leaf=""><br></span></code></pre><blockquote><p><span leaf="">min_expr这个参数没什么大用，可以通过检测 </span><code><span leaf="">detectGenes</span></code><span leaf=""> 函数源码发现，这个函数确实是通过分别计算：</span></p><ul><li><section><span leaf="">一个细胞中有多少基因的count &gt; min_expr，即 </span><code><span leaf="">colSums(exprs(cds) &amp;gt; min_expr)</span></code></section></li><li><section><span leaf="">一个基因在多少细胞中的count &gt; min_expr，即 </span><code><span leaf="">rowSums(exprs(cds) &amp;gt; min_expr)</span></code></section></li></ul><p><span leaf="">去计算得到每个基因中多少细胞表达，以及，每个细胞中多少基因表达</span></p></blockquote><p><strong><span leaf="">至少在10个细胞有表达水平超过阈值的基因</span></strong><span leaf="">，过滤基因，这些基因用于后续进行拟时序分析：</span></p><pre><code><span><span leaf=""># 至少在10个细胞有表达的基因</span></span><span leaf=""><br></span><span leaf="">expressed_genes &lt;- row.names(subset(fData(HSMM),</span><span leaf=""><br></span><span leaf="">    num_cells_expressed &gt;= </span><span><span leaf="">10</span></span><span leaf="">))</span><span leaf=""><br></span></code></pre><blockquote><p><span leaf="">在官方教程中，这里现暂时不删除没有达标的基因。</span></p></blockquote><p><strong><span leaf="">至少有50个基因表达水平超过阈值的细胞</span></strong><span leaf="">，过滤细胞：</span></p><pre><code><span><span leaf=""># 至少有1000个基因表达的细胞</span></span><span leaf=""><br></span><span leaf="">valid_cells &lt;- row.names(subset(pData(HSMM),</span><span leaf=""><br></span><span leaf="">    num_genes_expressed &gt;= </span><span><span leaf="">100</span></span><span leaf="">))</span><span leaf=""><br></span><span leaf="">HSMM &lt;- HSMM[,valid_cells]</span><span leaf=""><br></span></code></pre><p><span leaf="">考虑到数据分布对于后续分析的重要性，我们可以在过滤后进行一个简单检查：</span></p><pre><code><span><span leaf=""># Log-transform each value in the expression matrix.</span></span><span leaf=""><br></span><span leaf="">L &lt;- log(exprs(HSMM[expressed_genes,]))</span><span leaf=""><br></span><span leaf=""><br></span><span><span leaf=""># Standardize each gene, so that they are all on the same scale,</span></span><span leaf=""><br></span><span leaf="">melted_dens_df &lt;- melt(t(scale(t(L))))</span><span leaf=""><br></span><span leaf=""><br></span><span><span leaf=""># Plot the distribution of the standardized gene expression values.</span></span><span leaf=""><br></span><span leaf="">qplot(value, geom = </span><span><span leaf="">"density"</span></span><span leaf="">, data = melted_dens_df) +</span><span leaf=""><br></span><span leaf="">stat_function(fun = dnorm, size = </span><span><span leaf="">0.5</span></span><span leaf="">, color = </span><span><span leaf="">'red'</span></span><span leaf="">) +</span><span leaf=""><br></span><span leaf="">xlab(</span><span><span leaf="">"Standardized log(FPKM)"</span></span><span leaf="">) +</span><span leaf=""><br></span><span leaf="">ylab(</span><span><span leaf="">"Density"</span></span><span leaf="">)</span><span leaf=""><br></span></code></pre><section nodeleaf=""><img data-imgfileid="100006067" data-ratio="0.6373056994818653" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/fOo3cmIWvJq3UWDfu514zKexJsA5dLic9qbGPY9a4ep9oUahXNyaD3haFBIrgyMCTw81AG1WVXqpP7oTGOibmHTA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="386" type="block" src="https://mmbiz.qpic.cn/sz_mmbiz_png/fOo3cmIWvJq3UWDfu514zKexJsA5dLic9qbGPY9a4ep9oUahXNyaD3haFBIrgyMCTw81AG1WVXqpP7oTGOibmHTA/640?wx_fmt=png&amp;from=appmsg"></section><p><span leaf="">其中黑色的线是自己数据绘制出来的分布曲线，红色的线是根据自己数据计算出均值和方差后绘制的曲线。</span></p><h3><span><span leaf="">5. 细胞分群注释</span></span></h3><p><span leaf="">Monocle 提供了一个简单的系统，用于根据我们选择的标记基因的表达来鉴定细胞。</span></p><p><span leaf="">但是</span><strong><span leaf="">术业有专攻</span></strong><span leaf="">，monocle毕竟不是专门作细胞鉴定的软件，我们还是先在Seurat中做好细胞分群和注释后，再导入monocle进行分析。</span></p><h3><span><span leaf="">6. 构建单细胞轨迹</span></span></h3><p><strong><span leaf="">细胞从一种功能“状态”过渡到另一种功能“状态”，不同状态的细胞表达不同的基因组，产生一系列动态的蛋白质和代谢物来完成它们的工作。</span></strong></p><p><span leaf="">当细胞在不同状态之间移动时，会经历一个转录重组的过程，一些基因被沉默，另一些基因被激活。</span></p><p><span leaf="">Monocle 一旦了解基因表达变化的整体“轨迹”，就可以将每个细胞放置在轨迹中的适当位置。如果在轨迹过程有多个结果，Monocle 会重建一个“分支”轨迹。在生物学上，这些分支对应于细胞的“决定”。</span></p><p><span leaf="">Monocle 依赖于一种称为反向图嵌入（</span><em><span leaf="">Reversed Graph Embedding</span></em><span leaf="">）的机器学习技术来构建单细胞轨迹。</span></p><p><span leaf="">整个分析过程分为3个步骤，我们下面分别进行阐述。</span></p><blockquote><p><span leaf="">根据官网的教程，后续所有分析都基于一部分细胞的数据，由于我是自己构建的数据，所以这里仍然使用全部数据，只是为了保持代码一致，我将变量名进行更改。</span></p></blockquote><h4><span><span leaf="">6.1 选择决定过程的基因</span></span></h4><p><span leaf="">Monocle 需要寻找包含有关细胞状态的重要基因，利用这些基因进行轨迹的构建。所以一般来看，Monocle 会先进行差异表达基因，我们这里</span><strong><span leaf="">以不同细胞群为标准进行差异表达分析</span></strong><span leaf="">：</span></p><pre><code><span leaf="">diff_test_res &lt;- differentialGeneTest(HSMM_myo[expressed_genes,],</span><span leaf=""><br></span><span leaf="">                                      fullModelFormulaStr = </span><span><span leaf="">"~celltype"</span></span><span leaf="">)</span><span leaf=""><br></span><span leaf="">ordering_genes &lt;- row.names (subset(diff_test_res, qval &lt; </span><span><span leaf="">0.01</span></span><span leaf="">))</span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">HSMM_myo &lt;- setOrderingFilter(HSMM_myo, ordering_genes)</span><span leaf=""><br></span><span leaf="">plot_ordering_genes(HSMM_myo)</span><span leaf=""><br></span></code></pre><section nodeleaf=""><img data-imgfileid="100006068" data-ratio="1" data-s="300,640" data-src="https://mmbiz.qpic.cn/sz_mmbiz_png/fOo3cmIWvJq3UWDfu514zKexJsA5dLic9EPjpjShQ1NbnWzqLGCFDN0b6a1MFdobxoeibl3Z2UbM0eoAcZjrOahA/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="367" type="block" src="https://mmbiz.qpic.cn/sz_mmbiz_png/fOo3cmIWvJq3UWDfu514zKexJsA5dLic9EPjpjShQ1NbnWzqLGCFDN0b6a1MFdobxoeibl3Z2UbM0eoAcZjrOahA/640?wx_fmt=png&amp;from=appmsg"></section><p><span leaf="">此外，差异很大的基因通常具有很高的信息量，这些基因常常也可以用于识别细胞亚群或沿着轨迹排列细胞。这类似于Seurat中识别Highly variable genes的过程。</span></p><pre><code><span leaf="">disp_table &lt;- dispersionTable(HSMM_myo)</span><span leaf=""><br></span><span leaf="">head(disp_table)</span><span leaf=""><br></span><span><span leaf="">##         gene_id mean_expression dispersion_fit dispersion_empirical</span></span><span leaf=""><br></span><span><span leaf="">## 1    AL627309.1    0.0028788546      114.56445             0.000000</span></span><span leaf=""><br></span><span><span leaf="">## 2    AP006222.2    0.0009928841      317.37605             0.000000</span></span><span leaf=""><br></span><span><span leaf="">## 3 RP11-206L10.2    0.0011999423      263.95533             0.000000</span></span><span leaf=""><br></span><span><span leaf="">## 4 RP11-206L10.9    0.0005584922      558.16814             0.000000</span></span><span leaf=""><br></span><span><span leaf="">## 5     LINC00115    0.0058676574       60.17823             0.000000</span></span><span leaf=""><br></span><span><span leaf="">## 6         NOC2L    0.0976684126       10.93987             3.180171</span></span><span leaf=""><br></span><span leaf=""><br></span><span leaf="">ordering_genes &lt;- subset(disp_table,</span><span leaf=""><br></span><span leaf="">                  mean_expression &gt;= </span><span><span leaf="">0.5</span></span><span leaf=""> &amp;</span><span leaf=""><br></span><span leaf="">                  dispersion_empirical &gt;= </span><span><span leaf="">1</span></span><span leaf=""> * dispersion_fit)$gene_id</span><span leaf=""><br></span></code></pre><p><span leaf="">这里在软件手册中没有说明具体每一列的含义，不过根据我的检查，我认为这3列信息分别是：</span></p><ul><li><section><span leaf="">mean_expression：基因在所有细胞中的平均表达水平</span></section></li><li><section><span leaf="">dispersion_fit：根据均值离散度拟合的模型，计算得到在特定均值下的离散度</span></section></li><li><section><span leaf="">dispersion_empirical：实际基因的离散度</span></section></li></ul><blockquote><p><span leaf="">额外补充：为什么我们需要估计离散度（dispersion）？</span></p><p><span leaf="">低表达基因的噪声大，离散度高，例如某个基因在3个细胞间的表达水平分别为0.1,0.9,3.1。虽然绝对数值上相差不到3，但是从倍数上来看，相差了近30倍。这样来看的话，会导致低表达基因的噪声大，离散度高。而高表达基因的离散度则相对较小较可靠。</span></p><p><span leaf="">于是，为了弥补这部分低表达基因的情况，一般软件（尤其是做差异分析的软件）会利用所有基因的信息，</span><strong><span leaf="">建模离散度与均值的普遍关系</span></strong><span leaf="">。一般是用局部回归（如loess）拟合log⁡(原始离散度)和log(原始均值)之间的趋势线关系。</span></p><p><span leaf="">最后</span><strong><span leaf="">将不可靠的基因（低表达基因）原始离散度向趋势线收缩，提高稳定性</span></strong><span leaf="">。</span></p></blockquote><h4><span><span leaf="">6.2 减少数据的维度</span></span></h4><p><span leaf="">Monocle 使用 Reversed Graph Embedding 的算法来降低数据的维度。</span></p><pre><code><span leaf="">HSMM_myo &lt;- reduceDimension(HSMM_myo, max_components = </span><span><span leaf="">2</span></span><span leaf="">, method = </span><span><span leaf="">'DDRTree'</span></span><span leaf="">)</span><span leaf=""><br></span></code></pre><h4><span><span leaf="">6.3 在伪时间中对细胞排序</span></span></h4><p><span leaf="">Monocle 可以学习描述细胞如何从一种状态过渡到另一种状态的轨迹。Monocle 假设轨迹具有树形结构，其中一端是“根”，其他端是“叶”。</span></p><p><span leaf="">接下来我们使用 </span><code><span leaf="">orderCells</span></code><span leaf=""> 函数对细胞进行排序：</span></p><pre><code><span leaf="">HSMM_myo &lt;- orderCells(HSMM_myo)</span><span leaf=""><br></span></code></pre><blockquote><p><span leaf="">不知道是不是R版本更新的原因，我在运行这一步的时候，一直在报错：</span></p><section nodeleaf=""><span leaf="">[图片]</span></section><p><span leaf="">在尝试解决了一会后，发现简单方法无法解决，这里不想花费更多的时间探索了，简单记录如何使用，决定欢迎monocle3了。</span></p></blockquote><p><span leaf="">一旦细胞被排序，我们就可以在降维空间中可视化轨迹。</span></p><pre><code><span leaf="">plot_cell_trajectory(HSMM_myo, color_by = </span><span><span leaf="">"celltype"</span></span><span leaf="">, size=</span><span><span leaf="">1</span></span><span leaf="">,show_backbone=</span><span><span leaf="">TRUE</span></span><span leaf="">))</span><span leaf=""><br></span></code></pre><h3><span><span leaf="">后记</span></span></h3><p><span leaf="">目前大致知道了monocle2做轨迹分析的逻辑原理，后面我们还是测试使用monocle3~</span></p></section><section><span leaf=""><br></span></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/oF331mvcZE5IBfSlPQveOA",target="_blank" rel="noopener noreferrer">原文链接</a>
