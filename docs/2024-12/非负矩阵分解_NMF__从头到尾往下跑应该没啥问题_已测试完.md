---
title: "非负矩阵分解（NMF），从头到尾往下跑应该没啥问题，已测试完"
date: 2024-12-28T03:28:34Z
draft: ["false"]
tags: [
  "fetched",
  "生信钱同学"
]
categories: ["Acdemic"]
---
非负矩阵分解（NMF），从头到尾往下跑应该没啥问题，已测试完 by 生信钱同学
------
<div><p><strong>之前也介绍过很多次功能模块的角度去切入的文章</strong></p><p><span><strong>数据是两个样本随便做的，实际意义不具有参考价值，咱们直接以seurat对象入手，方便操作，下面是结果，如果样本多一点肯定会好看些</strong></span></p><p><img data-galleryid="" data-imgfileid="100007374" data-ratio="0.6178861788617886" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/7At0Eia3NQFvLkTmiatMia21NaIS9ruVkGk3QDTATpvXZ9M0QemuwVsOFW3deL7U0jiaHQiaiaunAlUdykz3tcjAAzrQ/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="984" src="https://mmbiz.qpic.cn/mmbiz_png/7At0Eia3NQFvLkTmiatMia21NaIS9ruVkGk3QDTATpvXZ9M0QemuwVsOFW3deL7U0jiaHQiaiaunAlUdykz3tcjAAzrQ/640?wx_fmt=png&amp;from=appmsg"></p><p>最后大家会拿到一个表，其中包含了每个program top30的gene，后面可以画个模块特意性基因的热图，很多文章都把非负矩阵分解用在了肿瘤细胞，其实啥细胞都行，只要这类细胞异质性比较大或者功能模块未知的话都可以用这个方法</p><p><img data-galleryid="" data-imgfileid="100007375" data-ratio="0.8611111111111112" data-s="300,640" data-src="https://mmbiz.qpic.cn/mmbiz_png/7At0Eia3NQFvLkTmiatMia21NaIS9ruVkGkAb3Heajlfhdvs6iccSPc8nuXqwibTO6jiahSg9gaCLPRp7ALqeyn07HCg/640?wx_fmt=png&amp;from=appmsg" data-type="png" data-w="1080" src="https://mmbiz.qpic.cn/mmbiz_png/7At0Eia3NQFvLkTmiatMia21NaIS9ruVkGkAb3Heajlfhdvs6iccSPc8nuXqwibTO6jiahSg9gaCLPRp7ALqeyn07HCg/640?wx_fmt=png&amp;from=appmsg"></p><p><br></p><section><ul><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li><li></ul><pre data-lang="php"><code><span><span>##############################################################################</span></span></code><code><span><span># 0. 加载必要的包</span></span></code><code><span><span>##############################################################################</span></span></code><code><span>library(Seurat)</span></code><code><span>library(NMF)        <span># 用于 NMF 分析</span></span></code><code><span>library(dplyr)      <span># 数据操作</span></span></code><code><span>library(tidyr)      <span># 数据整理</span></span></code><code><span>library(ComplexHeatmap)</span></code><code><span>library(ggplot2)</span></code><code><span><br></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 1. 读取已构建的 Seurat 对象，并提取恶性细胞（malignant cells）</span></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 假设你已有一个 Seurat 对象 "Seurat_obj"，里面包含所有细胞信息</span></span></code><code><span><span># 并且它的 meta.data 中有一列 "Harmony_SNN_res.0.6" 标注细胞类型/注释</span></span></code><code><span>Seurat_obj &lt;- readRDS(<span>"seurat.rds"</span>)</span></code><code><span><br></span></code><code><span><span># 提取目标细胞名称 (Target)</span></span></code><code><span>Target_cells &lt;- rownames(Seurat_obj@meta.data)[Seurat_obj@meta.data$Harmony_SNN_res<span>.0</span><span>.6</span> %in% c(<span>"9"</span>, <span>"12"</span>, <span>"14"</span>, <span>"16"</span>, <span>"21"</span>, <span>"22"</span>)]</span></code><code><span><br></span></code><code><span><span># 构建仅包含目标细胞的 Seurat 对象</span></span></code><code><span>Target_seurat &lt;- subset(Seurat_obj, cells = Target_cells)</span></code><code><span><br></span></code><code><span><span># 确保在后续操作中我们使用的是 RNA 表达数据</span></span></code><code><span>DefaultAssay(Target_seurat) &lt;- <span>"RNA"</span></span></code><code><span><br></span></code><code><span><span># 查看每个样本的目标细胞数量(可选)</span></span></code><code><span>table(Target_seurat@meta.data$sample)</span></code><code><span><br></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 2. 针对每个样本执行 NMF，并获取每个 program 的 top 30 基因</span></span></code><code><span><span>##############################################################################</span></span></code><code><span><br></span></code><code><span><span># 设置分解的 rank (这里取 12 个程序)</span></span></code><code><span>rank_k &lt;- <span>12</span></span></code><code><span><br></span></code><code><span><span># 用于保存所有样本的 Program 基因</span></span></code><code><span><span># 结构：每个列表元素对应 "sample_Program"，里面包含 top30 基因</span></span></code><code><span>all_programs_top30 &lt;- <span>list</span>()</span></code><code><span><br></span></code><code><span><span># 获取去重后的样本列表</span></span></code><code><span>sample_list &lt;- unique(Target_seurat@meta.data$sample)</span></code><code><span><br></span></code><code><span><span># 定义一个函数，对单个样本进行 NMF 分析，并提取 top30 基因</span></span></code><code><span>run_nmf_extract_top30 &lt;- <span><span>function</span><span>(sample_id)</span> </span>{</span></code><code><span>  </span></code><code><span>  <span># 1) 筛选该样本目标细胞</span></span></code><code><span>  temp_cells &lt;- rownames(Target_seurat@meta.data)[</span></code><code><span>    Target_seurat@meta.data$sample == sample_id</span></code><code><span>  ]</span></code><code><span>  </span></code><code><span>  <span># 2) 构建子集</span></span></code><code><span>  temp_seurat &lt;- subset(Target_seurat, cells = temp_cells)</span></code><code><span>  </span></code><code><span>  <span># 3) 对数据进行标准操作（Normalize, FindVariableFeatures, ScaleData）</span></span></code><code><span>  temp_seurat &lt;- NormalizeData(temp_seurat)</span></code><code><span>  temp_seurat &lt;- FindVariableFeatures(temp_seurat)</span></code><code><span>  temp_seurat &lt;- ScaleData(temp_seurat, <span>do</span>.center = <span>FALSE</span>)  <span># 不中心化</span></span></code><code><span>  </span></code><code><span>  <span># 4) 获取归一化后(或 scale 后)的表达矩阵</span></span></code><code><span>  exp_matrix &lt;- temp_seurat@assays$RNA@scale.data</span></code><code><span>  </span></code><code><span>  <span># 5) 进行 NMF 分解</span></span></code><code><span>  <span>#    这里选择 method="snmf/r"、设定 seed = 10，rank = rank_k(12)</span></span></code><code><span>  res_nmf &lt;- nmf(exp_matrix, rank_k, seed = <span>10</span>, method = <span>"snmf/r"</span>)</span></code><code><span>  </span></code><code><span>  <span># 6) 从结果中提取“基因权重矩阵”（Basis matrix），</span></span></code><code><span>  <span>#    通常 nmf 对象中使用 basis(res_nmf) 获取</span></span></code><code><span>  W &lt;- basis(res_nmf)  <span># 维度：基因数 x rank_k</span></span></code><code><span>  </span></code><code><span>  <span># 7) 对每个 program(列)按权重从大到小排序，选取 top30 基因</span></span></code><code><span>  top30_genes_list &lt;- apply(W, <span>2</span>, <span><span>function</span><span>(x)</span> </span>{</span></code><code><span>    <span># x 为当前 program 的所有基因权重</span></span></code><code><span>    <span># order() 默认从小到大，故加 decreasing = TRUE</span></span></code><code><span>    top_idx &lt;- order(x, decreasing = <span>TRUE</span>)[<span>1</span>:<span>30</span>]</span></code><code><span>    rownames(W)[top_idx]</span></code><code><span>  })</span></code><code><span>  </span></code><code><span>  <span># 命名行：program_1, program_2, ..., program_12</span></span></code><code><span>  colnames(top30_genes_list) &lt;- paste0(sample_id, <span>"_Program"</span>, <span>1</span>:rank_k)</span></code><code><span>  </span></code><code><span>  <span># 返回每列的 top30 基因</span></span></code><code><span>  <span>return</span>(top30_genes_list)</span></code><code><span>}</span></code><code><span><br></span></code><code><span><span># 使用 lapply 对所有样本循环运行上面的函数</span></span></code><code><span><span>for</span>(sample_id in sample_list){</span></code><code><span>  cat(<span>"Running NMF for sample:"</span>, sample_id, <span>"\n"</span>)</span></code><code><span>  gene_mat &lt;- run_nmf_extract_top30(sample_id)</span></code><code><span>  </span></code><code><span>  <span># 将每个 program 的 top30 基因存入全局列表</span></span></code><code><span>  <span># gene_mat 是一个矩阵，每列对应一个program</span></span></code><code><span>  <span># 做成一个数据框存储更方便后面分析</span></span></code><code><span>  <span>for</span>(program_name in colnames(gene_mat)){</span></code><code><span>    all_programs_top30[[ program_name ]] &lt;- gene_mat[, program_name]</span></code><code><span>  }</span></code><code><span>}</span></code><code><span><br></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 3. 计算所有 Program 之间的 Jaccard 相似度，并进行层次聚类</span></span></code><code><span><span>##############################################################################</span></span></code><code><span><br></span></code><code><span><span># all_programs_top30 是一个列表，其中每个元素都是 30 个基因</span></span></code><code><span><span># 我们需要比较所有 Program 两两之间的 Jaccard 相似度</span></span></code><code><span>program_names &lt;- names(all_programs_top30)</span></code><code><span><br></span></code><code><span><span># 构建空矩阵来存储 Jaccard 相似度</span></span></code><code><span>n_prog &lt;- length(program_names)</span></code><code><span>jaccard_mat &lt;- matrix(<span>0</span>, nrow = n_prog, ncol = n_prog,</span></code><code><span>                      dimnames = <span>list</span>(program_names, program_names))</span></code><code><span><br></span></code><code><span><span># 计算两两 Program 的 Jaccard</span></span></code><code><span><span>for</span>(i in seq_len(n_prog)){</span></code><code><span>  <span>for</span>(j in seq_len(n_prog)){</span></code><code><span>    set1 &lt;- all_programs_top30[[ i ]]</span></code><code><span>    set2 &lt;- all_programs_top30[[ j ]]</span></code><code><span>    inter_len &lt;- length(intersect(set1, set2))</span></code><code><span>    union_len &lt;- length(union(set1, set2))</span></code><code><span>    jaccard_mat[i, j] &lt;- inter_len / union_len</span></code><code><span>  }</span></code><code><span>}</span></code><code><span><br></span></code><code><span><span># 对 jaccard_mat 做层次聚类</span></span></code><code><span>dist_mat &lt;- <span>as</span>.dist(<span>1</span> - jaccard_mat)  <span># 相似度 -&gt; 距离</span></span></code><code><span>hc &lt;- hclust(dist_mat, method = <span>"ward.D2"</span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 4. 根据层次聚类结果归纳 meta-programs 并命名</span></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 假设我们想要按照某个 k（如 k=5）分成若干大类</span></span></code><code><span>k_meta &lt;- <span>5</span></span></code><code><span>cluster_cut &lt;- cutree(hc, k = k_meta)</span></code><code><span><br></span></code><code><span><span># 将每个 Program 的聚类结果合并到数据框</span></span></code><code><span>program_cluster_df &lt;- data.frame(</span></code><code><span>  Program = program_names,</span></code><code><span>  Cluster = cluster_cut</span></code><code><span>)</span></code><code><span><br></span></code><code><span><span># 打印查看</span></span></code><code><span>table(program_cluster_df$Cluster)</span></code><code><span><br></span></code><code><span><span># 给每个 meta-program（聚类）命名</span></span></code><code><span><span># 实际命名方式通常基于功能富集/GO/KEGG 分析结果</span></span></code><code><span><span># 这里简单示例</span></span></code><code><span>meta_program_names &lt;- c(<span>"MetaProg_Inflammation"</span>,</span></code><code><span>                        <span>"MetaProg_CellCycle"</span>,</span></code><code><span>                        <span>"MetaProg_Differentiation"</span>,</span></code><code><span>                        <span>"MetaProg_StressResponse"</span>,</span></code><code><span>                        <span>"MetaProg_Unknown"</span>)  <span># 需要自己修改</span></span></code><code><span><br></span></code><code><span><span># 依次给聚类 1, 2, 3, 4, 5 命名</span></span></code><code><span><span># 如果实际k_meta != 5，需要做相应修改</span></span></code><code><span>program_cluster_df$MetaProgramName &lt;- meta_program_names[program_cluster_df$Cluster]</span></code><code><span><br></span></code><code><span><span># 查看结果</span></span></code><code><span>head(program_cluster_df)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 5. 提取每个 meta-program 的 top30 基因</span></span></code><code><span><span>##############################################################################</span></span></code><code><span><br></span></code><code><span><span># 初始化一个列表，用于存储每个 meta-program 的 top30 基因</span></span></code><code><span>meta_program_top30 &lt;- <span>list</span>()</span></code><code><span><br></span></code><code><span><span># 遍历每个 meta-program，提取 top30 基因</span></span></code><code><span><span>for</span>(meta in unique(program_cluster_df$MetaProgramName)){</span></code><code><span>  </span></code><code><span>  <span># 获取属于该 meta-program 的所有 Program 名称</span></span></code><code><span>  progs &lt;- program_cluster_df$Program[program_cluster_df$MetaProgramName == meta]</span></code><code><span>  </span></code><code><span>  <span># 获取这些 Program 对应的所有基因</span></span></code><code><span>  genes &lt;- unlist(all_programs_top30[progs])</span></code><code><span>  </span></code><code><span>  <span># 统计每个基因出现的频率</span></span></code><code><span>  gene_freq &lt;- table(genes)</span></code><code><span>  </span></code><code><span>  <span># 按照频率从高到低排序</span></span></code><code><span>  gene_freq_sorted &lt;- sort(gene_freq, decreasing = <span>TRUE</span>)</span></code><code><span>  </span></code><code><span>  <span># 选择频率最高的前30个基因作为该 meta-program 的 top30 基因</span></span></code><code><span>  top30 &lt;- names(gene_freq_sorted)[<span>1</span>:<span>30</span>]</span></code><code><span>  </span></code><code><span>  <span># 将 top30 基因添加到列表中</span></span></code><code><span>  meta_program_top30[[meta]] &lt;- top30</span></code><code><span>}</span></code><code><span><br></span></code><code><span><span># 查看每个 meta-program 的 top30 基因</span></span></code><code><span><span>for</span>(meta in names(meta_program_top30)){</span></code><code><span>  cat(<span>"\n"</span>, meta, <span>"的 Top30 基因:\n"</span>)</span></code><code><span>  <span>print</span>(meta_program_top30[[meta]])</span></code><code><span>}</span></code><code><span><br></span></code><code><span><span># 画热图可视化</span></span></code><code><span>library(RColorBrewer)</span></code><code><span>program_cluster_df_anno=data.frame(row.names = rownames(program_cluster_df),MetaProgramName=program_cluster_df$MetaProgramName)</span></code><code><span><br></span></code><code><span>pheatmap(</span></code><code><span>  jaccard_mat,</span></code><code><span>  annotation_row = program_cluster_df_anno,  <span># 行注释</span></span></code><code><span>  show_colnames = <span>FALSE</span>,                     <span># 不显示列名</span></span></code><code><span>  show_rownames = <span>FALSE</span>,                     <span># 不显示行名</span></span></code><code><span>  cluster_rows = <span>TRUE</span>,                       <span># 启用行聚类</span></span></code><code><span>  cluster_cols = <span>TRUE</span>,                       <span># 启用列聚类</span></span></code><code><span>  treeheight_row = <span>20</span>,                       <span># 行聚类树高度</span></span></code><code><span>  treeheight_col = <span>20</span>,                       <span># 列聚类树高度</span></span></code><code><span>  cellwidth = <span>15</span>,                            <span># 单元格宽度</span></span></code><code><span>  cellheight = <span>15</span>,                           <span># 单元格高度</span></span></code><code><span>  annotation_colors = <span>list</span>(                  <span># 行注释颜色</span></span></code><code><span>    MetaProgramName = c(</span></code><code><span>      <span>"MetaProg_Inflammation"</span> = <span>"#a5c6dd"</span>,</span></code><code><span>      <span>"MetaProg_CellCycle"</span> = <span>"#487db2"</span>,</span></code><code><span>      <span>"MetaProg_Differentiation"</span> = <span>"#5da347"</span>,</span></code><code><span>      <span>"MetaProg_StressResponse"</span> = <span>"#eb9280"</span>,</span></code><code><span>      <span>"MetaProg_Unknown"</span> = <span>"#b0b0b0"</span></span></code><code><span>    )</span></code><code><span>  ),</span></code><code><span>  color = colorRampPalette(c(<span>"#f8e7d3"</span>, <span>"#fcaf72"</span>, <span>"#cd782d"</span>, <span>"firebrick3"</span>))(<span>50</span>), <span># 自定义颜色</span></span></code><code><span>  main = <span>"Heatmap of Jaccard Index"</span>          <span># 热图主标题</span></span></code><code><span>)</span></code><code><span><br></span></code><code><span><br></span></code><code><span><br></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 6. (可选) 保存结果，用于后续分析或可视化</span></span></code><code><span><span>##############################################################################</span></span></code><code><span><span># 1) 保存所有 Program top30 基因到文件</span></span></code><code><span><span>#    每列为 program 的 top30 基因</span></span></code><code><span>top30_output &lt;- <span>do</span>.call(cbind, all_programs_top30)</span></code><code><span>write.csv(top30_output, file = <span>"Allsamples_Programs_top30_genes.csv"</span>, row.names = <span>TRUE</span>)</span></code><code><span><br></span></code><code><span><span># 2) 保存 Jaccard 矩阵</span></span></code><code><span>write.csv(jaccard_mat, file = <span>"Allsamples_Programs_Jaccard_Matrix.csv"</span>, row.names = <span>TRUE</span>)</span></code><code><span><br></span></code><code><span><span># 3) 保存 Program 聚类及 meta-program 命名信息</span></span></code><code><span>write.csv(program_cluster_df, file = <span>"Allsamples_Programs_Cluster_Metaprogram.csv"</span>, row.names = <span>FALSE</span>)</span></code><code><span><br></span></code><code><span><span># 4) 保存每个 meta-program 的 top30 基因</span></span></code><code><span><span>#    以 CSV 格式保存，每个 meta-program 为一个单独的列</span></span></code><code><span>meta_top30_df &lt;- <span>as</span>.data.frame(meta_program_top30)</span></code><code><span>write.csv(meta_top30_df, file = <span>"MetaPrograms_Top30_Genes.csv"</span>, row.names = <span>FALSE</span>)</span></code><code><span><br></span></code><code><span><span># Done</span></span></code><code><span><br></span></code><code><span><br></span></code></pre></section><p><mp-style-type data-value="3"></mp-style-type></p></div>  
<hr>
<a href="https://mp.weixin.qq.com/s/SS76_rueKAnnZjn2e9fhdA",target="_blank" rel="noopener noreferrer">原文链接</a>
